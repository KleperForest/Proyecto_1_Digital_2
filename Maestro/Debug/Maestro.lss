
Maestro.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000003c  00800100  00000e14  00000ea8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000e14  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000002b  0080013c  0080013c  00000ee4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000ee4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000f14  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000148  00000000  00000000  00000f54  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001e48  00000000  00000000  0000109c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000b93  00000000  00000000  00002ee4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000f6b  00000000  00000000  00003a77  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000324  00000000  00000000  000049e4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000629  00000000  00000000  00004d08  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000c83  00000000  00000000  00005331  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000f8  00000000  00000000  00005fb4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 84 05 	jmp	0xb08	; 0xb08 <__vector_1>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 04 05 	jmp	0xa08	; 0xa08 <__vector_3>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 f0 04 	jmp	0x9e0	; 0x9e0 <__vector_18>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	e4 e1       	ldi	r30, 0x14	; 20
  7c:	fe e0       	ldi	r31, 0x0E	; 14
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	ac 33       	cpi	r26, 0x3C	; 60
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	21 e0       	ldi	r18, 0x01	; 1
  8c:	ac e3       	ldi	r26, 0x3C	; 60
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	a7 36       	cpi	r26, 0x67	; 103
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 76 01 	call	0x2ec	; 0x2ec <main>
  9e:	0c 94 08 07 	jmp	0xe10	; 0xe10 <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <I2C_Config_MASTER>:
	
	address <<= 1;  //Ubica la dirección y
	address |= 0x01; //habilita para reconocer las llamadas generales de I2C
	TWAR = address;
	
	TWCR = (1 << TWEA) | (1 << TWEN) | (1 << TWIE); //Habilita el BUS, con reconocimiento e interrupción
  a6:	cf 93       	push	r28
  a8:	c8 2f       	mov	r28, r24
  aa:	9a 01       	movw	r18, r20
  ac:	ab 01       	movw	r20, r22
  ae:	87 b1       	in	r24, 0x07	; 7
  b0:	8f 7c       	andi	r24, 0xCF	; 207
  b2:	87 b9       	out	0x07, r24	; 7
  b4:	60 e0       	ldi	r22, 0x00	; 0
  b6:	74 e2       	ldi	r23, 0x24	; 36
  b8:	84 ef       	ldi	r24, 0xF4	; 244
  ba:	90 e0       	ldi	r25, 0x00	; 0
  bc:	0e 94 a6 06 	call	0xd4c	; 0xd4c <__udivmodsi4>
  c0:	ca 01       	movw	r24, r20
  c2:	b9 01       	movw	r22, r18
  c4:	60 51       	subi	r22, 0x10	; 16
  c6:	71 09       	sbc	r23, r1
  c8:	81 09       	sbc	r24, r1
  ca:	91 09       	sbc	r25, r1
  cc:	2c 2f       	mov	r18, r28
  ce:	30 e0       	ldi	r19, 0x00	; 0
  d0:	22 0f       	add	r18, r18
  d2:	33 1f       	adc	r19, r19
  d4:	03 2e       	mov	r0, r19
  d6:	00 0c       	add	r0, r0
  d8:	44 0b       	sbc	r20, r20
  da:	55 0b       	sbc	r21, r21
  dc:	0e 94 a6 06 	call	0xd4c	; 0xd4c <__udivmodsi4>
  e0:	20 93 b8 00 	sts	0x00B8, r18	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7f80b8>
  e4:	c4 30       	cpi	r28, 0x04	; 4
  e6:	79 f0       	breq	.+30     	; 0x106 <I2C_Config_MASTER+0x60>
  e8:	18 f4       	brcc	.+6      	; 0xf0 <I2C_Config_MASTER+0x4a>
  ea:	c1 30       	cpi	r28, 0x01	; 1
  ec:	31 f0       	breq	.+12     	; 0xfa <I2C_Config_MASTER+0x54>
  ee:	23 c0       	rjmp	.+70     	; 0x136 <I2C_Config_MASTER+0x90>
  f0:	c0 31       	cpi	r28, 0x10	; 16
  f2:	91 f0       	breq	.+36     	; 0x118 <I2C_Config_MASTER+0x72>
  f4:	c0 34       	cpi	r28, 0x40	; 64
  f6:	c9 f0       	breq	.+50     	; 0x12a <I2C_Config_MASTER+0x84>
  f8:	1e c0       	rjmp	.+60     	; 0x136 <I2C_Config_MASTER+0x90>
  fa:	e9 eb       	ldi	r30, 0xB9	; 185
  fc:	f0 e0       	ldi	r31, 0x00	; 0
  fe:	80 81       	ld	r24, Z
 100:	8c 7f       	andi	r24, 0xFC	; 252
 102:	80 83       	st	Z, r24
 104:	1d c0       	rjmp	.+58     	; 0x140 <I2C_Config_MASTER+0x9a>
 106:	e9 eb       	ldi	r30, 0xB9	; 185
 108:	f0 e0       	ldi	r31, 0x00	; 0
 10a:	80 81       	ld	r24, Z
 10c:	8d 7f       	andi	r24, 0xFD	; 253
 10e:	80 83       	st	Z, r24
 110:	80 81       	ld	r24, Z
 112:	81 60       	ori	r24, 0x01	; 1
 114:	80 83       	st	Z, r24
 116:	14 c0       	rjmp	.+40     	; 0x140 <I2C_Config_MASTER+0x9a>
 118:	e9 eb       	ldi	r30, 0xB9	; 185
 11a:	f0 e0       	ldi	r31, 0x00	; 0
 11c:	80 81       	ld	r24, Z
 11e:	8e 7f       	andi	r24, 0xFE	; 254
 120:	80 83       	st	Z, r24
 122:	80 81       	ld	r24, Z
 124:	82 60       	ori	r24, 0x02	; 2
 126:	80 83       	st	Z, r24
 128:	0b c0       	rjmp	.+22     	; 0x140 <I2C_Config_MASTER+0x9a>
 12a:	e9 eb       	ldi	r30, 0xB9	; 185
 12c:	f0 e0       	ldi	r31, 0x00	; 0
 12e:	80 81       	ld	r24, Z
 130:	8d 6f       	ori	r24, 0xFD	; 253
 132:	80 83       	st	Z, r24
 134:	05 c0       	rjmp	.+10     	; 0x140 <I2C_Config_MASTER+0x9a>
 136:	e9 eb       	ldi	r30, 0xB9	; 185
 138:	f0 e0       	ldi	r31, 0x00	; 0
 13a:	80 81       	ld	r24, Z
 13c:	8c 7f       	andi	r24, 0xFC	; 252
 13e:	80 83       	st	Z, r24
 140:	84 e0       	ldi	r24, 0x04	; 4
 142:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
 146:	cf 91       	pop	r28
 148:	08 95       	ret

0000014a <I2C_inicio>:
}


uint8_t I2C_inicio(){
	uint8_t edo;  //Variable que indica que no se consiguió el bus 
	TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTA); //Condición de inicio
 14a:	84 ea       	ldi	r24, 0xA4	; 164
 14c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
	while (!(TWCR & (1 << TWINT)));  //Espera la bandera TWINT
 150:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
 154:	88 23       	and	r24, r24
 156:	e4 f7       	brge	.-8      	; 0x150 <I2C_inicio+0x6>
	edo = TWSR & 0xF8; //Obtiene el estado, 1 condicion de inicio, o 2 inicio repetido
 158:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7f80b9>
 15c:	88 7f       	andi	r24, 0xF8	; 248
	
	if (edo == 0x08 || edo == 0x10) 
 15e:	88 30       	cpi	r24, 0x08	; 8
 160:	21 f0       	breq	.+8      	; 0x16a <I2C_inicio+0x20>
 162:	80 31       	cpi	r24, 0x10	; 16
 164:	19 f4       	brne	.+6      	; 0x16c <I2C_inicio+0x22>
	{
		return 1;
 166:	81 e0       	ldi	r24, 0x01	; 1
 168:	08 95       	ret
 16a:	81 e0       	ldi	r24, 0x01	; 1
	}
	
	return edo;  
	
}
 16c:	08 95       	ret

0000016e <I2C_EscByte>:
//Regresa: 0x01 envio sin problemas, edo, si el dato no se envio como se esperaba

uint8_t I2C_EscByte(uint8_t dato){
	uint8_t edo;
	
	TWDR = dato;      //Carga el dato   
 16e:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7f80bb>
	TWCR = (1 << TWEN) | (1 << TWINT);   //Inicia el envio
 172:	84 e8       	ldi	r24, 0x84	; 132
 174:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
	
	while (!(TWCR & (1 << TWINT))); //espera la bandera TWINT
 178:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
 17c:	88 23       	and	r24, r24
 17e:	e4 f7       	brge	.-8      	; 0x178 <I2C_EscByte+0xa>
	edo = TWSR & 0xF8; //Obtiene el estado
 180:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7f80b9>
 184:	88 7f       	andi	r24, 0xF8	; 248
	
	    //Hay 3 posibilidades de éxito:
	if (edo == 0x18 || edo == 0x28 || edo == 0x40)  //Transmitió una SLA+W CON ACK, transimitió una SLA+R con ACK, Transmitió un dato con ACK
 186:	88 31       	cpi	r24, 0x18	; 24
 188:	31 f0       	breq	.+12     	; 0x196 <I2C_EscByte+0x28>
 18a:	88 32       	cpi	r24, 0x28	; 40
 18c:	31 f0       	breq	.+12     	; 0x19a <I2C_EscByte+0x2c>
 18e:	80 34       	cpi	r24, 0x40	; 64
 190:	29 f4       	brne	.+10     	; 0x19c <I2C_EscByte+0x2e>
	{
		return 0x01;
 192:	81 e0       	ldi	r24, 0x01	; 1
 194:	08 95       	ret
 196:	81 e0       	ldi	r24, 0x01	; 1
 198:	08 95       	ret
 19a:	81 e0       	ldi	r24, 0x01	; 1
	}
	return edo;   //So hay algún error
	
}
 19c:	08 95       	ret

0000019e <I2C_STOP>:

void I2C_STOP(){
	TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);  //Condición de Paro
 19e:	84 e9       	ldi	r24, 0x94	; 148
 1a0:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
	while (TWCR & (1 << TWSTO));  //El bit se limpia por HW
 1a4:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
 1a8:	84 fd       	sbrc	r24, 4
 1aa:	fc cf       	rjmp	.-8      	; 0x1a4 <I2C_STOP+0x6>
}
 1ac:	08 95       	ret

000001ae <I2C_esclavo>:


  //Envia datos al esclavo
void I2C_esclavo(uint8_t dato, uint8_t direction){
 1ae:	cf 93       	push	r28
 1b0:	c8 2f       	mov	r28, r24
	esclavo = direction;  //Dirección del esclavo
	esclavo = esclavo << 1;    //Compone la SLA+W*************************************************************************
 1b2:	66 0f       	add	r22, r22
 1b4:	60 93 4d 01 	sts	0x014D, r22	; 0x80014d <esclavo>
	
	
	aux = I2C_inicio();   //Condicion de inicio
 1b8:	0e 94 a5 00 	call	0x14a	; 0x14a <I2C_inicio>
 1bc:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <aux>
	if (aux != 0x01)  //Si no se establece la conexión
 1c0:	81 30       	cpi	r24, 0x01	; 1
 1c2:	31 f0       	breq	.+12     	; 0x1d0 <I2C_esclavo+0x22>
	{
		TWCR |= (1 << TWINT);  //Borrar la bandera
 1c4:	ec eb       	ldi	r30, 0xBC	; 188
 1c6:	f0 e0       	ldi	r31, 0x00	; 0
 1c8:	80 81       	ld	r24, Z
 1ca:	80 68       	ori	r24, 0x80	; 128
 1cc:	80 83       	st	Z, r24
		return;   //No continua
 1ce:	10 c0       	rjmp	.+32     	; 0x1f0 <I2C_esclavo+0x42>
	}
	
	aux = I2C_EscByte(esclavo);     //Direcciona con la SLA+W
 1d0:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <esclavo>
 1d4:	0e 94 b7 00 	call	0x16e	; 0x16e <I2C_EscByte>
 1d8:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <aux>
	if (aux != 0x01)   //Si hay algun error de comunicación
 1dc:	81 30       	cpi	r24, 0x01	; 1
 1de:	19 f0       	breq	.+6      	; 0x1e6 <I2C_esclavo+0x38>
	{
		I2C_STOP();  //No continua, termina la comunicación y la cierra
 1e0:	0e 94 cf 00 	call	0x19e	; 0x19e <I2C_STOP>
		return;   
 1e4:	05 c0       	rjmp	.+10     	; 0x1f0 <I2C_esclavo+0x42>
	}
	
	I2C_EscByte(dato);   //Envia el dato al esclavo
 1e6:	8c 2f       	mov	r24, r28
 1e8:	0e 94 b7 00 	call	0x16e	; 0x16e <I2C_EscByte>
	I2C_STOP();  //No continua, termina la comunicación y la cierra
 1ec:	0e 94 cf 00 	call	0x19e	; 0x19e <I2C_STOP>
	
	
}
 1f0:	cf 91       	pop	r28
 1f2:	08 95       	ret

000001f4 <I2C_leer_dato>:


// Lee un byte de datos del esclavo I2C
int I2C_leer_dato(uint8_t direccion_esclavo, int *dato) {
 1f4:	cf 93       	push	r28
 1f6:	df 93       	push	r29
	// Iniciar condición de START
	TWCR = (1 << TWSTA) | (1 << TWEN) | (1 << TWINT);
 1f8:	94 ea       	ldi	r25, 0xA4	; 164
 1fa:	90 93 bc 00 	sts	0x00BC, r25	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
	while (!(TWCR & (1 << TWINT))); // Esperar a que se complete
 1fe:	90 91 bc 00 	lds	r25, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
 202:	99 23       	and	r25, r25
 204:	e4 f7       	brge	.-8      	; 0x1fe <I2C_leer_dato+0xa>

	// Verificar condición de START
	if ((TWSR & 0xF8) != TW_START) {
 206:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7f80b9>
 20a:	98 7f       	andi	r25, 0xF8	; 248
 20c:	98 30       	cpi	r25, 0x08	; 8
 20e:	e1 f5       	brne	.+120    	; 0x288 <I2C_leer_dato+0x94>
		return 1; // Error: No se pudo iniciar la condición de START
	}

	// Enviar dirección del esclavo con bit de lectura
	TWDR = SLA_R(direccion_esclavo);
 210:	90 e0       	ldi	r25, 0x00	; 0
 212:	88 0f       	add	r24, r24
 214:	99 1f       	adc	r25, r25
 216:	81 60       	ori	r24, 0x01	; 1
 218:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7f80bb>
	TWCR = (1 << TWEN) | (1 << TWINT);
 21c:	84 e8       	ldi	r24, 0x84	; 132
 21e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
	while (!(TWCR & (1 << TWINT))); // Esperar a que se complete la transmisión de la dirección
 222:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
 226:	88 23       	and	r24, r24
 228:	e4 f7       	brge	.-8      	; 0x222 <I2C_leer_dato+0x2e>
 22a:	eb 01       	movw	r28, r22

	// Verificar ACK/NACK de la dirección
	uint8_t twsr_value = TWSR & 0xF8;
 22c:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7f80b9>
 230:	88 7f       	andi	r24, 0xF8	; 248
	if (twsr_value == TW_MR_SLA_NACK) {
 232:	88 34       	cpi	r24, 0x48	; 72
 234:	29 f4       	brne	.+10     	; 0x240 <I2C_leer_dato+0x4c>
		I2C_STOP(); // Detener si se recibe un NACK
 236:	0e 94 cf 00 	call	0x19e	; 0x19e <I2C_STOP>
		return 1; // Error: NACK recibido
 23a:	81 e0       	ldi	r24, 0x01	; 1
 23c:	90 e0       	ldi	r25, 0x00	; 0
 23e:	26 c0       	rjmp	.+76     	; 0x28c <I2C_leer_dato+0x98>
		} else if (twsr_value != TW_MR_SLA_ACK) {
 240:	80 34       	cpi	r24, 0x40	; 64
 242:	29 f0       	breq	.+10     	; 0x24e <I2C_leer_dato+0x5a>
		I2C_STOP(); // Detener si otro estado inesperado
 244:	0e 94 cf 00 	call	0x19e	; 0x19e <I2C_STOP>
		return 1; // Error: Estado inesperado
 248:	81 e0       	ldi	r24, 0x01	; 1
 24a:	90 e0       	ldi	r25, 0x00	; 0
 24c:	1f c0       	rjmp	.+62     	; 0x28c <I2C_leer_dato+0x98>
	}

	// Leer un byte del esclavo
	TWCR = (1 << TWEN) | (1 << TWINT); // Leer sin ACK (NACK)
 24e:	84 e8       	ldi	r24, 0x84	; 132
 250:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
	while (!(TWCR & (1 << TWINT))); // Esperar a que se complete la recepción
 254:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
 258:	88 23       	and	r24, r24
 25a:	e4 f7       	brge	.-8      	; 0x254 <I2C_leer_dato+0x60>

	// Verificar estado de recepción
	twsr_value = TWSR & 0xF8;
 25c:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7f80b9>
 260:	88 7f       	andi	r24, 0xF8	; 248
	if (twsr_value != TW_MR_DATA_NACK && twsr_value != TW_MR_DATA_ACK) {
 262:	88 35       	cpi	r24, 0x58	; 88
 264:	39 f0       	breq	.+14     	; 0x274 <I2C_leer_dato+0x80>
 266:	80 35       	cpi	r24, 0x50	; 80
 268:	29 f0       	breq	.+10     	; 0x274 <I2C_leer_dato+0x80>
		I2C_STOP(); // Detener si hay error en la recepción
 26a:	0e 94 cf 00 	call	0x19e	; 0x19e <I2C_STOP>
		return 1; // Error en la recepción
 26e:	81 e0       	ldi	r24, 0x01	; 1
 270:	90 e0       	ldi	r25, 0x00	; 0
 272:	0c c0       	rjmp	.+24     	; 0x28c <I2C_leer_dato+0x98>
	}

	// Leer el dato recibido
	*dato = TWDR;
 274:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7f80bb>
 278:	90 e0       	ldi	r25, 0x00	; 0
 27a:	99 83       	std	Y+1, r25	; 0x01
 27c:	88 83       	st	Y, r24

	// Generar condición de STOP
      I2C_STOP();
 27e:	0e 94 cf 00 	call	0x19e	; 0x19e <I2C_STOP>
  
	return  *dato; // Éxito
 282:	88 81       	ld	r24, Y
 284:	99 81       	ldd	r25, Y+1	; 0x01
 286:	02 c0       	rjmp	.+4      	; 0x28c <I2C_leer_dato+0x98>
	TWCR = (1 << TWSTA) | (1 << TWEN) | (1 << TWINT);
	while (!(TWCR & (1 << TWINT))); // Esperar a que se complete

	// Verificar condición de START
	if ((TWSR & 0xF8) != TW_START) {
		return 1; // Error: No se pudo iniciar la condición de START
 288:	81 e0       	ldi	r24, 0x01	; 1
 28a:	90 e0       	ldi	r25, 0x00	; 0

	// Generar condición de STOP
      I2C_STOP();
  
	return  *dato; // Éxito
}
 28c:	df 91       	pop	r29
 28e:	cf 91       	pop	r28
 290:	08 95       	ret

00000292 <setup>:
 
 uint8_t data = 10;
 
void setup(void);
void setup(void){
	cli();  //Apagar interrupciones
 292:	f8 94       	cli
	DDRD = 0xFF;  //Puerto D como salida
 294:	8f ef       	ldi	r24, 0xFF	; 255
 296:	8a b9       	out	0x0a, r24	; 10
	DDRC = 0x03;  //Puerto C como salida
 298:	83 e0       	ldi	r24, 0x03	; 3
 29a:	87 b9       	out	0x07, r24	; 7
	
	 DDRD &= ~(1 << PIND2);   // Configura PD2 como entrada
 29c:	8a b1       	in	r24, 0x0a	; 10
 29e:	8b 7f       	andi	r24, 0xFB	; 251
 2a0:	8a b9       	out	0x0a, r24	; 10
	 PORTD |= (1 << PIND2);   // Habilita el pull-up interno en PD2 
 2a2:	8b b1       	in	r24, 0x0b	; 11
 2a4:	84 60       	ori	r24, 0x04	; 4
 2a6:	8b b9       	out	0x0b, r24	; 11
	
	DDRB = 0b00000000; //Entrada sensores infrarrojos
 2a8:	14 b8       	out	0x04, r1	; 4
	PORTB = 0b00000111;		//pull up encendido en PB0 y PB1 
 2aa:	87 e0       	ldi	r24, 0x07	; 7
 2ac:	85 b9       	out	0x05, r24	; 5
	
	PCMSK0 |= (1 << 0) | (1 << 1); //PCINT0
 2ae:	eb e6       	ldi	r30, 0x6B	; 107
 2b0:	f0 e0       	ldi	r31, 0x00	; 0
 2b2:	80 81       	ld	r24, Z
 2b4:	83 60       	ori	r24, 0x03	; 3
 2b6:	80 83       	st	Z, r24
	PCICR |= (1 << 0); //Mascara de interrupción
 2b8:	e8 e6       	ldi	r30, 0x68	; 104
 2ba:	f0 e0       	ldi	r31, 0x00	; 0
 2bc:	80 81       	ld	r24, Z
 2be:	81 60       	ori	r24, 0x01	; 1
 2c0:	80 83       	st	Z, r24
	
	EICRA &= ~((1 << ISC01) | (1 << ISC00));  // Configura INT0 para que se dispare en nivel bajo
 2c2:	e9 e6       	ldi	r30, 0x69	; 105
 2c4:	f0 e0       	ldi	r31, 0x00	; 0
 2c6:	80 81       	ld	r24, Z
 2c8:	8c 7f       	andi	r24, 0xFC	; 252
 2ca:	80 83       	st	Z, r24
	EIMSK |= (1 << INT0);  // Habilita la interrupción externa INT0
 2cc:	8d b3       	in	r24, 0x1d	; 29
 2ce:	81 60       	ori	r24, 0x01	; 1
 2d0:	8d bb       	out	0x1d, r24	; 29
	
	initUART9600();  //Iniciar UART
 2d2:	0e 94 58 06 	call	0xcb0	; 0xcb0 <initUART9600>
    I2C_Config_MASTER(4, 200000);  //Configurar  el atmega328P como maestro de I2C
 2d6:	40 e4       	ldi	r20, 0x40	; 64
 2d8:	5d e0       	ldi	r21, 0x0D	; 13
 2da:	63 e0       	ldi	r22, 0x03	; 3
 2dc:	70 e0       	ldi	r23, 0x00	; 0
 2de:	84 e0       	ldi	r24, 0x04	; 4
 2e0:	0e 94 53 00 	call	0xa6	; 0xa6 <I2C_Config_MASTER>
	SPI_init();
 2e4:	0e 94 39 06 	call	0xc72	; 0xc72 <SPI_init>
	

	sei(); //Activar interrupciones
 2e8:	78 94       	sei
 2ea:	08 95       	ret

000002ec <main>:
}


int main(void)
{
    setup();
 2ec:	0e 94 49 01 	call	0x292	; 0x292 <setup>
		
    while (1) 
    {
		
		// Leer la fecha y hora del RTC DS3231
		leer_fecha_hora(&segundos, &minutos, &horas, &dia, &fecha, &mes, &anio);
 2f0:	0f 2e       	mov	r0, r31
 2f2:	f2 e5       	ldi	r31, 0x52	; 82
 2f4:	cf 2e       	mov	r12, r31
 2f6:	f1 e0       	ldi	r31, 0x01	; 1
 2f8:	df 2e       	mov	r13, r31
 2fa:	f0 2d       	mov	r31, r0
 2fc:	0f 2e       	mov	r0, r31
 2fe:	f5 e6       	ldi	r31, 0x65	; 101
 300:	ef 2e       	mov	r14, r31
 302:	f1 e0       	ldi	r31, 0x01	; 1
 304:	ff 2e       	mov	r15, r31
 306:	f0 2d       	mov	r31, r0
 308:	04 e6       	ldi	r16, 0x64	; 100
 30a:	11 e0       	ldi	r17, 0x01	; 1
 30c:	2f e4       	ldi	r18, 0x4F	; 79
 30e:	31 e0       	ldi	r19, 0x01	; 1
 310:	4e e4       	ldi	r20, 0x4E	; 78
 312:	51 e0       	ldi	r21, 0x01	; 1
 314:	66 e6       	ldi	r22, 0x66	; 102
 316:	71 e0       	ldi	r23, 0x01	; 1
 318:	83 e5       	ldi	r24, 0x53	; 83
 31a:	91 e0       	ldi	r25, 0x01	; 1
 31c:	0e 94 dd 05 	call	0xbba	; 0xbba <leer_fecha_hora>
	
		
		
		  //Verificar la hora de encendido y apagado del sistema 
		if (horaencendido == horas)
 320:	80 91 4e 01 	lds	r24, 0x014E	; 0x80014e <horas>
 324:	90 e0       	ldi	r25, 0x00	; 0
 326:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <horaencendido>
 32a:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <horaencendido+0x1>
 32e:	82 17       	cp	r24, r18
 330:	93 07       	cpc	r25, r19
 332:	31 f5       	brne	.+76     	; 0x380 <main+0x94>
		{
			if (minutoencendido == minutos)
 334:	80 91 66 01 	lds	r24, 0x0166	; 0x800166 <minutos>
 338:	90 e0       	ldi	r25, 0x00	; 0
 33a:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 33e:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
 342:	82 17       	cp	r24, r18
 344:	93 07       	cpc	r25, r19
 346:	e1 f4       	brne	.+56     	; 0x380 <main+0x94>
			{
				I2C_esclavo(10,ESCLAVO1);
 348:	63 e0       	ldi	r22, 0x03	; 3
 34a:	8a e0       	ldi	r24, 0x0A	; 10
 34c:	0e 94 d7 00 	call	0x1ae	; 0x1ae <I2C_esclavo>
				
				if (contador2 < 1)
 350:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <contador2>
 354:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <contador2+0x1>
 358:	18 16       	cp	r1, r24
 35a:	19 06       	cpc	r1, r25
 35c:	8c f0       	brlt	.+34     	; 0x380 <main+0x94>
				{
					I2C_esclavo(10,ESCLAVO2);
 35e:	62 e0       	ldi	r22, 0x02	; 2
 360:	8a e0       	ldi	r24, 0x0A	; 10
 362:	0e 94 d7 00 	call	0x1ae	; 0x1ae <I2C_esclavo>
					contador2 = contador2 + 1;
 366:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <contador2>
 36a:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <contador2+0x1>
 36e:	01 96       	adiw	r24, 0x01	; 1
 370:	90 93 3f 01 	sts	0x013F, r25	; 0x80013f <contador2+0x1>
 374:	80 93 3e 01 	sts	0x013E, r24	; 0x80013e <contador2>
					contador3 = 0;
 378:	10 92 3d 01 	sts	0x013D, r1	; 0x80013d <__data_end+0x1>
 37c:	10 92 3c 01 	sts	0x013C, r1	; 0x80013c <__data_end>
				}
				
			}
		}
		
		if (horaapagado == horas)
 380:	80 91 4e 01 	lds	r24, 0x014E	; 0x80014e <horas>
 384:	90 e0       	ldi	r25, 0x00	; 0
 386:	20 91 46 01 	lds	r18, 0x0146	; 0x800146 <horaapagado>
 38a:	30 91 47 01 	lds	r19, 0x0147	; 0x800147 <horaapagado+0x1>
 38e:	82 17       	cp	r24, r18
 390:	93 07       	cpc	r25, r19
 392:	31 f5       	brne	.+76     	; 0x3e0 <main+0xf4>
		{
			if (minutoapagado == minutos)
 394:	80 91 66 01 	lds	r24, 0x0166	; 0x800166 <minutos>
 398:	90 e0       	ldi	r25, 0x00	; 0
 39a:	20 91 44 01 	lds	r18, 0x0144	; 0x800144 <minutoapagado>
 39e:	30 91 45 01 	lds	r19, 0x0145	; 0x800145 <minutoapagado+0x1>
 3a2:	82 17       	cp	r24, r18
 3a4:	93 07       	cpc	r25, r19
 3a6:	e1 f4       	brne	.+56     	; 0x3e0 <main+0xf4>
			{
				I2C_esclavo(11, ESCLAVO1);
 3a8:	63 e0       	ldi	r22, 0x03	; 3
 3aa:	8b e0       	ldi	r24, 0x0B	; 11
 3ac:	0e 94 d7 00 	call	0x1ae	; 0x1ae <I2C_esclavo>
				
				if (contador3 < 1)
 3b0:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <__data_end>
 3b4:	90 91 3d 01 	lds	r25, 0x013D	; 0x80013d <__data_end+0x1>
 3b8:	18 16       	cp	r1, r24
 3ba:	19 06       	cpc	r1, r25
 3bc:	8c f0       	brlt	.+34     	; 0x3e0 <main+0xf4>
				{
					contador1 = 0;
 3be:	10 92 41 01 	sts	0x0141, r1	; 0x800141 <contador1+0x1>
 3c2:	10 92 40 01 	sts	0x0140, r1	; 0x800140 <contador1>
					contador2 = 0;
 3c6:	10 92 3f 01 	sts	0x013F, r1	; 0x80013f <contador2+0x1>
 3ca:	10 92 3e 01 	sts	0x013E, r1	; 0x80013e <contador2>
					contador = 0;
 3ce:	10 92 43 01 	sts	0x0143, r1	; 0x800143 <contador+0x1>
 3d2:	10 92 42 01 	sts	0x0142, r1	; 0x800142 <contador>
					contador3 = contador3 + 1;
 3d6:	01 96       	adiw	r24, 0x01	; 1
 3d8:	90 93 3d 01 	sts	0x013D, r25	; 0x80013d <__data_end+0x1>
 3dc:	80 93 3c 01 	sts	0x013C, r24	; 0x80013c <__data_end>
		
		
		
		
		 
		if (receivedChar != 0)   //Cada vez que se tiene una entrada por UART
 3e0:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <receivedChar>
 3e4:	88 23       	and	r24, r24
 3e6:	09 f4       	brne	.+2      	; 0x3ea <main+0xfe>
 3e8:	f4 c2       	rjmp	.+1512   	; 0x9d2 <__stack+0xd3>
		{
			if (receivedChar == 'A')  //Si se requiere ver la hora y fecha actual del sistema
 3ea:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <receivedChar>
 3ee:	81 34       	cpi	r24, 0x41	; 65
 3f0:	c1 f5       	brne	.+112    	; 0x462 <__EEPROM_REGION_LENGTH__+0x62>
			{
				// Imprimir la hora y la fecha
				//HORA:
				UART_PrintNum(horas);
 3f2:	80 91 4e 01 	lds	r24, 0x014E	; 0x80014e <horas>
 3f6:	90 e0       	ldi	r25, 0x00	; 0
 3f8:	0e 94 8b 06 	call	0xd16	; 0xd16 <UART_PrintNum>
				writeUART(':');
 3fc:	8a e3       	ldi	r24, 0x3A	; 58
 3fe:	0e 94 84 06 	call	0xd08	; 0xd08 <writeUART>
				UART_PrintNum(minutos);
 402:	80 91 66 01 	lds	r24, 0x0166	; 0x800166 <minutos>
 406:	90 e0       	ldi	r25, 0x00	; 0
 408:	0e 94 8b 06 	call	0xd16	; 0xd16 <UART_PrintNum>
				writeUART(':');
 40c:	8a e3       	ldi	r24, 0x3A	; 58
 40e:	0e 94 84 06 	call	0xd08	; 0xd08 <writeUART>
				UART_PrintNum(segundos);
 412:	80 91 53 01 	lds	r24, 0x0153	; 0x800153 <segundos>
 416:	90 e0       	ldi	r25, 0x00	; 0
 418:	0e 94 8b 06 	call	0xd16	; 0xd16 <UART_PrintNum>
				writeTextUART(" ");
 41c:	8a e3       	ldi	r24, 0x3A	; 58
 41e:	91 e0       	ldi	r25, 0x01	; 1
 420:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				writeTextUART("_");    //Separador de fecha y hora
 424:	84 e0       	ldi	r24, 0x04	; 4
 426:	91 e0       	ldi	r25, 0x01	; 1
 428:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				//FECHA
				UART_PrintNum(fecha);
 42c:	80 91 64 01 	lds	r24, 0x0164	; 0x800164 <fecha>
 430:	90 e0       	ldi	r25, 0x00	; 0
 432:	0e 94 8b 06 	call	0xd16	; 0xd16 <UART_PrintNum>
				writeUART('/');
 436:	8f e2       	ldi	r24, 0x2F	; 47
 438:	0e 94 84 06 	call	0xd08	; 0xd08 <writeUART>
				UART_PrintNum(mes);
 43c:	80 91 65 01 	lds	r24, 0x0165	; 0x800165 <mes>
 440:	90 e0       	ldi	r25, 0x00	; 0
 442:	0e 94 8b 06 	call	0xd16	; 0xd16 <UART_PrintNum>
				writeUART('/');
 446:	8f e2       	ldi	r24, 0x2F	; 47
 448:	0e 94 84 06 	call	0xd08	; 0xd08 <writeUART>
				UART_PrintNum(anio + 2000 );  // Asumiendo que el año es en formato 2 dígitos y se quiere imprimir en formato 4 dígitos
 44c:	80 91 52 01 	lds	r24, 0x0152	; 0x800152 <anio>
 450:	90 e0       	ldi	r25, 0x00	; 0
 452:	80 53       	subi	r24, 0x30	; 48
 454:	98 4f       	sbci	r25, 0xF8	; 248
 456:	0e 94 8b 06 	call	0xd16	; 0xd16 <UART_PrintNum>
				writeTextUART("\n");
 45a:	86 e0       	ldi	r24, 0x06	; 6
 45c:	91 e0       	ldi	r25, 0x01	; 1
 45e:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
			}
			
			
			if (receivedChar == 'Z')  //Si se desea reiniciar la máquina
 462:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <receivedChar>
 466:	8a 35       	cpi	r24, 0x5A	; 90
 468:	21 f4       	brne	.+8      	; 0x472 <__EEPROM_REGION_LENGTH__+0x72>
			{
				I2C_esclavo(75,ESCLAVO1);
 46a:	63 e0       	ldi	r22, 0x03	; 3
 46c:	8b e4       	ldi	r24, 0x4B	; 75
 46e:	0e 94 d7 00 	call	0x1ae	; 0x1ae <I2C_esclavo>
			}
			
			if (receivedChar == 'B')  //Si se requiere manejar el brazo robotico individual
 472:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <receivedChar>
 476:	82 34       	cpi	r24, 0x42	; 66
 478:	19 f4       	brne	.+6      	; 0x480 <__EEPROM_REGION_LENGTH__+0x80>
			{
				brazo = 1;
 47a:	81 e0       	ldi	r24, 0x01	; 1
 47c:	80 93 48 01 	sts	0x0148, r24	; 0x800148 <brazo>
			}
			
			if (brazo == 1)    //Si se activa la función de manejar el brazo con los jostick
 480:	80 91 48 01 	lds	r24, 0x0148	; 0x800148 <brazo>
 484:	81 30       	cpi	r24, 0x01	; 1
 486:	09 f0       	breq	.+2      	; 0x48a <__EEPROM_REGION_LENGTH__+0x8a>
 488:	40 c0       	rjmp	.+128    	; 0x50a <__EEPROM_REGION_LENGTH__+0x10a>
			{
				if (receivedChar == 'C')
 48a:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <receivedChar>
 48e:	83 34       	cpi	r24, 0x43	; 67
 490:	21 f4       	brne	.+8      	; 0x49a <__EEPROM_REGION_LENGTH__+0x9a>
				{
					I2C_esclavo(1,ESCLAVO1);
 492:	63 e0       	ldi	r22, 0x03	; 3
 494:	81 e0       	ldi	r24, 0x01	; 1
 496:	0e 94 d7 00 	call	0x1ae	; 0x1ae <I2C_esclavo>
				
					
				}
				
				if (receivedChar == 'D')
 49a:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <receivedChar>
 49e:	84 34       	cpi	r24, 0x44	; 68
 4a0:	21 f4       	brne	.+8      	; 0x4aa <__EEPROM_REGION_LENGTH__+0xaa>
				{
					I2C_esclavo(2,ESCLAVO1);
 4a2:	63 e0       	ldi	r22, 0x03	; 3
 4a4:	82 e0       	ldi	r24, 0x02	; 2
 4a6:	0e 94 d7 00 	call	0x1ae	; 0x1ae <I2C_esclavo>
					
					
				}
				
				if (receivedChar == 'E')
 4aa:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <receivedChar>
 4ae:	85 34       	cpi	r24, 0x45	; 69
 4b0:	21 f4       	brne	.+8      	; 0x4ba <__EEPROM_REGION_LENGTH__+0xba>
				{
					I2C_esclavo(3,ESCLAVO1);
 4b2:	63 e0       	ldi	r22, 0x03	; 3
 4b4:	83 e0       	ldi	r24, 0x03	; 3
 4b6:	0e 94 d7 00 	call	0x1ae	; 0x1ae <I2C_esclavo>
				}
				
				if (receivedChar == 'F')
 4ba:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <receivedChar>
 4be:	86 34       	cpi	r24, 0x46	; 70
 4c0:	21 f4       	brne	.+8      	; 0x4ca <__EEPROM_REGION_LENGTH__+0xca>
				{
					
					I2C_esclavo(4,ESCLAVO1);
 4c2:	63 e0       	ldi	r22, 0x03	; 3
 4c4:	84 e0       	ldi	r24, 0x04	; 4
 4c6:	0e 94 d7 00 	call	0x1ae	; 0x1ae <I2C_esclavo>
				}
				
				
				if (receivedChar == 'G')
 4ca:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <receivedChar>
 4ce:	87 34       	cpi	r24, 0x47	; 71
 4d0:	21 f4       	brne	.+8      	; 0x4da <__EEPROM_REGION_LENGTH__+0xda>
				{
					I2C_esclavo(5,ESCLAVO1);
 4d2:	63 e0       	ldi	r22, 0x03	; 3
 4d4:	85 e0       	ldi	r24, 0x05	; 5
 4d6:	0e 94 d7 00 	call	0x1ae	; 0x1ae <I2C_esclavo>
				}
				
				
				if (receivedChar == 'H')
 4da:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <receivedChar>
 4de:	88 34       	cpi	r24, 0x48	; 72
 4e0:	21 f4       	brne	.+8      	; 0x4ea <__EEPROM_REGION_LENGTH__+0xea>
				{
					I2C_esclavo(6,ESCLAVO1);
 4e2:	63 e0       	ldi	r22, 0x03	; 3
 4e4:	86 e0       	ldi	r24, 0x06	; 6
 4e6:	0e 94 d7 00 	call	0x1ae	; 0x1ae <I2C_esclavo>
				}
				
				if (receivedChar == 'I')
 4ea:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <receivedChar>
 4ee:	89 34       	cpi	r24, 0x49	; 73
 4f0:	21 f4       	brne	.+8      	; 0x4fa <__EEPROM_REGION_LENGTH__+0xfa>
				{
					I2C_esclavo(7,ESCLAVO1);
 4f2:	63 e0       	ldi	r22, 0x03	; 3
 4f4:	87 e0       	ldi	r24, 0x07	; 7
 4f6:	0e 94 d7 00 	call	0x1ae	; 0x1ae <I2C_esclavo>
				}
				
				if (receivedChar == 'J')
 4fa:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <receivedChar>
 4fe:	8a 34       	cpi	r24, 0x4A	; 74
 500:	21 f4       	brne	.+8      	; 0x50a <__EEPROM_REGION_LENGTH__+0x10a>
				{
					I2C_esclavo(8,ESCLAVO1);
 502:	63 e0       	ldi	r22, 0x03	; 3
 504:	88 e0       	ldi	r24, 0x08	; 8
 506:	0e 94 d7 00 	call	0x1ae	; 0x1ae <I2C_esclavo>
				}
			}
			
			if (receivedChar == 'R') //Si se desea manipular las llantas de la máquina
 50a:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <receivedChar>
 50e:	82 35       	cpi	r24, 0x52	; 82
 510:	19 f4       	brne	.+6      	; 0x518 <__EEPROM_REGION_LENGTH__+0x118>
			{
				brazo = 2;     //Desactivar manejar el brazo de manera individual y colocar las llantas
 512:	82 e0       	ldi	r24, 0x02	; 2
 514:	80 93 48 01 	sts	0x0148, r24	; 0x800148 <brazo>
				
			}
			
			if (brazo == 2)
 518:	80 91 48 01 	lds	r24, 0x0148	; 0x800148 <brazo>
 51c:	82 30       	cpi	r24, 0x02	; 2
 51e:	a1 f5       	brne	.+104    	; 0x588 <__EEPROM_REGION_LENGTH__+0x188>
			{
				if (receivedChar == 'E')
 520:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <receivedChar>
 524:	85 34       	cpi	r24, 0x45	; 69
 526:	41 f4       	brne	.+16     	; 0x538 <__EEPROM_REGION_LENGTH__+0x138>
				{
					I2C_esclavo(1,ESCLAVO2);
 528:	62 e0       	ldi	r22, 0x02	; 2
 52a:	81 e0       	ldi	r24, 0x01	; 1
 52c:	0e 94 d7 00 	call	0x1ae	; 0x1ae <I2C_esclavo>
					UART_PrintNum(1);
 530:	81 e0       	ldi	r24, 0x01	; 1
 532:	90 e0       	ldi	r25, 0x00	; 0
 534:	0e 94 8b 06 	call	0xd16	; 0xd16 <UART_PrintNum>
				}
				
				if (receivedChar == 'F')
 538:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <receivedChar>
 53c:	86 34       	cpi	r24, 0x46	; 70
 53e:	41 f4       	brne	.+16     	; 0x550 <__EEPROM_REGION_LENGTH__+0x150>
				{
					
					I2C_esclavo(2,ESCLAVO2);
 540:	62 e0       	ldi	r22, 0x02	; 2
 542:	82 e0       	ldi	r24, 0x02	; 2
 544:	0e 94 d7 00 	call	0x1ae	; 0x1ae <I2C_esclavo>
					UART_PrintNum(2);
 548:	82 e0       	ldi	r24, 0x02	; 2
 54a:	90 e0       	ldi	r25, 0x00	; 0
 54c:	0e 94 8b 06 	call	0xd16	; 0xd16 <UART_PrintNum>
				}
				
				
				if (receivedChar == 'G')
 550:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <receivedChar>
 554:	87 34       	cpi	r24, 0x47	; 71
 556:	41 f4       	brne	.+16     	; 0x568 <__EEPROM_REGION_LENGTH__+0x168>
				{
					I2C_esclavo(3,ESCLAVO2);
 558:	62 e0       	ldi	r22, 0x02	; 2
 55a:	83 e0       	ldi	r24, 0x03	; 3
 55c:	0e 94 d7 00 	call	0x1ae	; 0x1ae <I2C_esclavo>
					UART_PrintNum(3);
 560:	83 e0       	ldi	r24, 0x03	; 3
 562:	90 e0       	ldi	r25, 0x00	; 0
 564:	0e 94 8b 06 	call	0xd16	; 0xd16 <UART_PrintNum>
				}
				
				
				if (receivedChar == 'H')
 568:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <receivedChar>
 56c:	88 34       	cpi	r24, 0x48	; 72
 56e:	41 f4       	brne	.+16     	; 0x580 <__EEPROM_REGION_LENGTH__+0x180>
				{
					I2C_esclavo(4,ESCLAVO2);
 570:	62 e0       	ldi	r22, 0x02	; 2
 572:	84 e0       	ldi	r24, 0x04	; 4
 574:	0e 94 d7 00 	call	0x1ae	; 0x1ae <I2C_esclavo>
					UART_PrintNum(4);
 578:	84 e0       	ldi	r24, 0x04	; 4
 57a:	90 e0       	ldi	r25, 0x00	; 0
 57c:	0e 94 8b 06 	call	0xd16	; 0xd16 <UART_PrintNum>
				}
				writeUART(receivedChar);
 580:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <receivedChar>
 584:	0e 94 84 06 	call	0xd08	; 0xd08 <writeUART>
				
			}
			
			if (receivedChar == 'T') //Si se desea cambiar la hora de encendido de la banda transportadora
 588:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <receivedChar>
 58c:	84 35       	cpi	r24, 0x54	; 84
 58e:	09 f0       	breq	.+2      	; 0x592 <__EEPROM_REGION_LENGTH__+0x192>
 590:	5b c0       	rjmp	.+182    	; 0x648 <__EEPROM_REGION_LENGTH__+0x248>
			{
				brazo = 3;     //Activar cambio de hora y minuto
 592:	83 e0       	ldi	r24, 0x03	; 3
 594:	80 93 48 01 	sts	0x0148, r24	; 0x800148 <brazo>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 598:	8f e1       	ldi	r24, 0x1F	; 31
 59a:	9e e4       	ldi	r25, 0x4E	; 78
 59c:	01 97       	sbiw	r24, 0x01	; 1
 59e:	f1 f7       	brne	.-4      	; 0x59c <__EEPROM_REGION_LENGTH__+0x19c>
 5a0:	00 c0       	rjmp	.+0      	; 0x5a2 <__EEPROM_REGION_LENGTH__+0x1a2>
 5a2:	00 00       	nop
				_delay_ms(5);
				UART_PrintNum(horaencendido);
 5a4:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <horaencendido>
 5a8:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <horaencendido+0x1>
 5ac:	0e 94 8b 06 	call	0xd16	; 0xd16 <UART_PrintNum>
				writeTextUART(" ");
 5b0:	8a e3       	ldi	r24, 0x3A	; 58
 5b2:	91 e0       	ldi	r25, 0x01	; 1
 5b4:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				writeTextUART(" ");
 5b8:	8a e3       	ldi	r24, 0x3A	; 58
 5ba:	91 e0       	ldi	r25, 0x01	; 1
 5bc:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				writeTextUART(" ");
 5c0:	8a e3       	ldi	r24, 0x3A	; 58
 5c2:	91 e0       	ldi	r25, 0x01	; 1
 5c4:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				writeTextUART(" ");
 5c8:	8a e3       	ldi	r24, 0x3A	; 58
 5ca:	91 e0       	ldi	r25, 0x01	; 1
 5cc:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				writeTextUART(" ");
 5d0:	8a e3       	ldi	r24, 0x3A	; 58
 5d2:	91 e0       	ldi	r25, 0x01	; 1
 5d4:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				writeTextUART(" ");
 5d8:	8a e3       	ldi	r24, 0x3A	; 58
 5da:	91 e0       	ldi	r25, 0x01	; 1
 5dc:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				writeTextUART(" ");
 5e0:	8a e3       	ldi	r24, 0x3A	; 58
 5e2:	91 e0       	ldi	r25, 0x01	; 1
 5e4:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				writeTextUART("_");    //Separador de hora y minuto
 5e8:	84 e0       	ldi	r24, 0x04	; 4
 5ea:	91 e0       	ldi	r25, 0x01	; 1
 5ec:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				UART_PrintNum(minutoencendido);
 5f0:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 5f4:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
 5f8:	0e 94 8b 06 	call	0xd16	; 0xd16 <UART_PrintNum>
				writeTextUART(" ");
 5fc:	8a e3       	ldi	r24, 0x3A	; 58
 5fe:	91 e0       	ldi	r25, 0x01	; 1
 600:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				writeTextUART(" ");
 604:	8a e3       	ldi	r24, 0x3A	; 58
 606:	91 e0       	ldi	r25, 0x01	; 1
 608:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				writeTextUART(" ");
 60c:	8a e3       	ldi	r24, 0x3A	; 58
 60e:	91 e0       	ldi	r25, 0x01	; 1
 610:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				writeTextUART(" ");
 614:	8a e3       	ldi	r24, 0x3A	; 58
 616:	91 e0       	ldi	r25, 0x01	; 1
 618:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				writeTextUART(" ");
 61c:	8a e3       	ldi	r24, 0x3A	; 58
 61e:	91 e0       	ldi	r25, 0x01	; 1
 620:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				writeTextUART(" ");
 624:	8a e3       	ldi	r24, 0x3A	; 58
 626:	91 e0       	ldi	r25, 0x01	; 1
 628:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				writeTextUART(" ");
 62c:	8a e3       	ldi	r24, 0x3A	; 58
 62e:	91 e0       	ldi	r25, 0x01	; 1
 630:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				writeTextUART("\n");
 634:	86 e0       	ldi	r24, 0x06	; 6
 636:	91 e0       	ldi	r25, 0x01	; 1
 638:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
 63c:	8f e1       	ldi	r24, 0x1F	; 31
 63e:	9e e4       	ldi	r25, 0x4E	; 78
 640:	01 97       	sbiw	r24, 0x01	; 1
 642:	f1 f7       	brne	.-4      	; 0x640 <__EEPROM_REGION_LENGTH__+0x240>
 644:	00 c0       	rjmp	.+0      	; 0x646 <__EEPROM_REGION_LENGTH__+0x246>
 646:	00 00       	nop
				_delay_ms(5);
			}
			
			if (brazo == 3)  //Si se desea cambiar la hora de encendido de la banda
 648:	80 91 48 01 	lds	r24, 0x0148	; 0x800148 <brazo>
 64c:	83 30       	cpi	r24, 0x03	; 3
 64e:	09 f0       	breq	.+2      	; 0x652 <__EEPROM_REGION_LENGTH__+0x252>
 650:	62 c0       	rjmp	.+196    	; 0x716 <__EEPROM_REGION_LENGTH__+0x316>
			{
				if (receivedChar == 'a')
 652:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <receivedChar>
 656:	81 36       	cpi	r24, 0x61	; 97
 658:	49 f4       	brne	.+18     	; 0x66c <__EEPROM_REGION_LENGTH__+0x26c>
				{
					horaencendido++;
 65a:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <horaencendido>
 65e:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <horaencendido+0x1>
 662:	01 96       	adiw	r24, 0x01	; 1
 664:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <horaencendido+0x1>
 668:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <horaencendido>
				}
				if (receivedChar == 'b')
 66c:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <receivedChar>
 670:	82 36       	cpi	r24, 0x62	; 98
 672:	49 f4       	brne	.+18     	; 0x686 <__EEPROM_REGION_LENGTH__+0x286>
				{
					horaencendido--;
 674:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <horaencendido>
 678:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <horaencendido+0x1>
 67c:	01 97       	sbiw	r24, 0x01	; 1
 67e:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <horaencendido+0x1>
 682:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <horaencendido>
				}
				
				if (receivedChar == 'c')
 686:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <receivedChar>
 68a:	83 36       	cpi	r24, 0x63	; 99
 68c:	49 f4       	brne	.+18     	; 0x6a0 <__EEPROM_REGION_LENGTH__+0x2a0>
				{
					minutoencendido++;
 68e:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 692:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
 696:	01 96       	adiw	r24, 0x01	; 1
 698:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
 69c:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
				}
				if (receivedChar == 'd')
 6a0:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <receivedChar>
 6a4:	84 36       	cpi	r24, 0x64	; 100
 6a6:	49 f4       	brne	.+18     	; 0x6ba <__EEPROM_REGION_LENGTH__+0x2ba>
				{
					minutoencendido--;
 6a8:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 6ac:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
 6b0:	01 97       	sbiw	r24, 0x01	; 1
 6b2:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
 6b6:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
				}
				
				if (horaencendido >= 23)
 6ba:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <horaencendido>
 6be:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <horaencendido+0x1>
 6c2:	47 97       	sbiw	r24, 0x17	; 23
 6c4:	34 f0       	brlt	.+12     	; 0x6d2 <__EEPROM_REGION_LENGTH__+0x2d2>
				{
					horaencendido = 23;
 6c6:	87 e1       	ldi	r24, 0x17	; 23
 6c8:	90 e0       	ldi	r25, 0x00	; 0
 6ca:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <horaencendido+0x1>
 6ce:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <horaencendido>
				}
				
				if (horaencendido <= 0)
 6d2:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <horaencendido>
 6d6:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <horaencendido+0x1>
 6da:	18 16       	cp	r1, r24
 6dc:	19 06       	cpc	r1, r25
 6de:	24 f0       	brlt	.+8      	; 0x6e8 <__EEPROM_REGION_LENGTH__+0x2e8>
				{
					horaencendido = 0;
 6e0:	10 92 03 01 	sts	0x0103, r1	; 0x800103 <horaencendido+0x1>
 6e4:	10 92 02 01 	sts	0x0102, r1	; 0x800102 <horaencendido>
				}
				
				if (minutoencendido >= 59)
 6e8:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 6ec:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
 6f0:	cb 97       	sbiw	r24, 0x3b	; 59
 6f2:	34 f0       	brlt	.+12     	; 0x700 <__EEPROM_REGION_LENGTH__+0x300>
				{
					minutoencendido = 59;
 6f4:	8b e3       	ldi	r24, 0x3B	; 59
 6f6:	90 e0       	ldi	r25, 0x00	; 0
 6f8:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
 6fc:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
				}
				
				if (minutoencendido <= 0)
 700:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 704:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
 708:	18 16       	cp	r1, r24
 70a:	19 06       	cpc	r1, r25
 70c:	24 f0       	brlt	.+8      	; 0x716 <__EEPROM_REGION_LENGTH__+0x316>
				{
					minutoencendido = 0;
 70e:	10 92 01 01 	sts	0x0101, r1	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
 712:	10 92 00 01 	sts	0x0100, r1	; 0x800100 <__DATA_REGION_ORIGIN__>
				
				
			}
			
			
			if (receivedChar == 'Y') //Si se desea cambiar la hora de apagado de la banda transportadora
 716:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <receivedChar>
 71a:	89 35       	cpi	r24, 0x59	; 89
 71c:	09 f0       	breq	.+2      	; 0x720 <__EEPROM_REGION_LENGTH__+0x320>
 71e:	53 c0       	rjmp	.+166    	; 0x7c6 <__EEPROM_REGION_LENGTH__+0x3c6>
			{
				brazo = 4;     //Activar cambio de hora y minuto
 720:	84 e0       	ldi	r24, 0x04	; 4
 722:	80 93 48 01 	sts	0x0148, r24	; 0x800148 <brazo>
 726:	8f e1       	ldi	r24, 0x1F	; 31
 728:	9e e4       	ldi	r25, 0x4E	; 78
 72a:	01 97       	sbiw	r24, 0x01	; 1
 72c:	f1 f7       	brne	.-4      	; 0x72a <__EEPROM_REGION_LENGTH__+0x32a>
 72e:	00 c0       	rjmp	.+0      	; 0x730 <__EEPROM_REGION_LENGTH__+0x330>
 730:	00 00       	nop
				_delay_ms(5);
				UART_PrintNum(horaapagado);
 732:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <horaapagado>
 736:	90 91 47 01 	lds	r25, 0x0147	; 0x800147 <horaapagado+0x1>
 73a:	0e 94 8b 06 	call	0xd16	; 0xd16 <UART_PrintNum>
				writeTextUART(" ");
 73e:	8a e3       	ldi	r24, 0x3A	; 58
 740:	91 e0       	ldi	r25, 0x01	; 1
 742:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				writeTextUART(" ");
 746:	8a e3       	ldi	r24, 0x3A	; 58
 748:	91 e0       	ldi	r25, 0x01	; 1
 74a:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				writeTextUART(" ");
 74e:	8a e3       	ldi	r24, 0x3A	; 58
 750:	91 e0       	ldi	r25, 0x01	; 1
 752:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				writeTextUART(" ");
 756:	8a e3       	ldi	r24, 0x3A	; 58
 758:	91 e0       	ldi	r25, 0x01	; 1
 75a:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				writeTextUART(" ");
 75e:	8a e3       	ldi	r24, 0x3A	; 58
 760:	91 e0       	ldi	r25, 0x01	; 1
 762:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				writeTextUART(" ");
 766:	8a e3       	ldi	r24, 0x3A	; 58
 768:	91 e0       	ldi	r25, 0x01	; 1
 76a:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				writeTextUART(" ");
 76e:	8a e3       	ldi	r24, 0x3A	; 58
 770:	91 e0       	ldi	r25, 0x01	; 1
 772:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				writeTextUART("_");    //Separador de hora y minuto
 776:	84 e0       	ldi	r24, 0x04	; 4
 778:	91 e0       	ldi	r25, 0x01	; 1
 77a:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				UART_PrintNum(minutoapagado);
 77e:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <minutoapagado>
 782:	90 91 45 01 	lds	r25, 0x0145	; 0x800145 <minutoapagado+0x1>
 786:	0e 94 8b 06 	call	0xd16	; 0xd16 <UART_PrintNum>
				writeTextUART(" ");
 78a:	8a e3       	ldi	r24, 0x3A	; 58
 78c:	91 e0       	ldi	r25, 0x01	; 1
 78e:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				writeTextUART(" ");
 792:	8a e3       	ldi	r24, 0x3A	; 58
 794:	91 e0       	ldi	r25, 0x01	; 1
 796:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				writeTextUART(" ");
 79a:	8a e3       	ldi	r24, 0x3A	; 58
 79c:	91 e0       	ldi	r25, 0x01	; 1
 79e:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				writeTextUART(" ");
 7a2:	8a e3       	ldi	r24, 0x3A	; 58
 7a4:	91 e0       	ldi	r25, 0x01	; 1
 7a6:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				writeTextUART(" ");
 7aa:	8a e3       	ldi	r24, 0x3A	; 58
 7ac:	91 e0       	ldi	r25, 0x01	; 1
 7ae:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				writeTextUART("\n");
 7b2:	86 e0       	ldi	r24, 0x06	; 6
 7b4:	91 e0       	ldi	r25, 0x01	; 1
 7b6:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
 7ba:	8f e1       	ldi	r24, 0x1F	; 31
 7bc:	9e e4       	ldi	r25, 0x4E	; 78
 7be:	01 97       	sbiw	r24, 0x01	; 1
 7c0:	f1 f7       	brne	.-4      	; 0x7be <__EEPROM_REGION_LENGTH__+0x3be>
 7c2:	00 c0       	rjmp	.+0      	; 0x7c4 <__EEPROM_REGION_LENGTH__+0x3c4>
 7c4:	00 00       	nop
				_delay_ms(5);
			}
			
			if (brazo == 4)  //Si se desea cambiar la hora de apagado de la banda
 7c6:	80 91 48 01 	lds	r24, 0x0148	; 0x800148 <brazo>
 7ca:	84 30       	cpi	r24, 0x04	; 4
 7cc:	09 f0       	breq	.+2      	; 0x7d0 <__EEPROM_REGION_LENGTH__+0x3d0>
 7ce:	62 c0       	rjmp	.+196    	; 0x894 <__DATA_REGION_LENGTH__+0x94>
			{
				if (receivedChar == 'a')
 7d0:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <receivedChar>
 7d4:	81 36       	cpi	r24, 0x61	; 97
 7d6:	49 f4       	brne	.+18     	; 0x7ea <__EEPROM_REGION_LENGTH__+0x3ea>
				{
					horaapagado++;
 7d8:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <horaapagado>
 7dc:	90 91 47 01 	lds	r25, 0x0147	; 0x800147 <horaapagado+0x1>
 7e0:	01 96       	adiw	r24, 0x01	; 1
 7e2:	90 93 47 01 	sts	0x0147, r25	; 0x800147 <horaapagado+0x1>
 7e6:	80 93 46 01 	sts	0x0146, r24	; 0x800146 <horaapagado>
				}
				if (receivedChar == 'b')
 7ea:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <receivedChar>
 7ee:	82 36       	cpi	r24, 0x62	; 98
 7f0:	49 f4       	brne	.+18     	; 0x804 <__DATA_REGION_LENGTH__+0x4>
				{
					horaapagado--;
 7f2:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <horaapagado>
 7f6:	90 91 47 01 	lds	r25, 0x0147	; 0x800147 <horaapagado+0x1>
 7fa:	01 97       	sbiw	r24, 0x01	; 1
 7fc:	90 93 47 01 	sts	0x0147, r25	; 0x800147 <horaapagado+0x1>
 800:	80 93 46 01 	sts	0x0146, r24	; 0x800146 <horaapagado>
				}
				
				if (receivedChar == 'c')
 804:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <receivedChar>
 808:	83 36       	cpi	r24, 0x63	; 99
 80a:	49 f4       	brne	.+18     	; 0x81e <__DATA_REGION_LENGTH__+0x1e>
				{
					minutoapagado++;
 80c:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <minutoapagado>
 810:	90 91 45 01 	lds	r25, 0x0145	; 0x800145 <minutoapagado+0x1>
 814:	01 96       	adiw	r24, 0x01	; 1
 816:	90 93 45 01 	sts	0x0145, r25	; 0x800145 <minutoapagado+0x1>
 81a:	80 93 44 01 	sts	0x0144, r24	; 0x800144 <minutoapagado>
				}
				if (receivedChar == 'd')
 81e:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <receivedChar>
 822:	84 36       	cpi	r24, 0x64	; 100
 824:	49 f4       	brne	.+18     	; 0x838 <__DATA_REGION_LENGTH__+0x38>
				{
					minutoapagado--;
 826:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <minutoapagado>
 82a:	90 91 45 01 	lds	r25, 0x0145	; 0x800145 <minutoapagado+0x1>
 82e:	01 97       	sbiw	r24, 0x01	; 1
 830:	90 93 45 01 	sts	0x0145, r25	; 0x800145 <minutoapagado+0x1>
 834:	80 93 44 01 	sts	0x0144, r24	; 0x800144 <minutoapagado>
				}
				
				if (horaapagado >= 23)
 838:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <horaapagado>
 83c:	90 91 47 01 	lds	r25, 0x0147	; 0x800147 <horaapagado+0x1>
 840:	47 97       	sbiw	r24, 0x17	; 23
 842:	34 f0       	brlt	.+12     	; 0x850 <__DATA_REGION_LENGTH__+0x50>
				{
					horaapagado = 23;
 844:	87 e1       	ldi	r24, 0x17	; 23
 846:	90 e0       	ldi	r25, 0x00	; 0
 848:	90 93 47 01 	sts	0x0147, r25	; 0x800147 <horaapagado+0x1>
 84c:	80 93 46 01 	sts	0x0146, r24	; 0x800146 <horaapagado>
				}
				
				if (horaapagado <= 0)
 850:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <horaapagado>
 854:	90 91 47 01 	lds	r25, 0x0147	; 0x800147 <horaapagado+0x1>
 858:	18 16       	cp	r1, r24
 85a:	19 06       	cpc	r1, r25
 85c:	24 f0       	brlt	.+8      	; 0x866 <__DATA_REGION_LENGTH__+0x66>
				{
					horaapagado = 0;
 85e:	10 92 47 01 	sts	0x0147, r1	; 0x800147 <horaapagado+0x1>
 862:	10 92 46 01 	sts	0x0146, r1	; 0x800146 <horaapagado>
				}
				
				if (minutoapagado >= 59)
 866:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <minutoapagado>
 86a:	90 91 45 01 	lds	r25, 0x0145	; 0x800145 <minutoapagado+0x1>
 86e:	cb 97       	sbiw	r24, 0x3b	; 59
 870:	34 f0       	brlt	.+12     	; 0x87e <__DATA_REGION_LENGTH__+0x7e>
				{
					minutoapagado = 59;
 872:	8b e3       	ldi	r24, 0x3B	; 59
 874:	90 e0       	ldi	r25, 0x00	; 0
 876:	90 93 45 01 	sts	0x0145, r25	; 0x800145 <minutoapagado+0x1>
 87a:	80 93 44 01 	sts	0x0144, r24	; 0x800144 <minutoapagado>
				}
				
				if (minutoapagado <= 0)
 87e:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <minutoapagado>
 882:	90 91 45 01 	lds	r25, 0x0145	; 0x800145 <minutoapagado+0x1>
 886:	18 16       	cp	r1, r24
 888:	19 06       	cpc	r1, r25
 88a:	24 f0       	brlt	.+8      	; 0x894 <__DATA_REGION_LENGTH__+0x94>
				{
					minutoapagado = 0;
 88c:	10 92 45 01 	sts	0x0145, r1	; 0x800145 <minutoapagado+0x1>
 890:	10 92 44 01 	sts	0x0144, r1	; 0x800144 <minutoapagado>
				}
				
				
			}
			
			if (receivedChar == 'K')
 894:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <receivedChar>
 898:	8b 34       	cpi	r24, 0x4B	; 75
 89a:	09 f0       	breq	.+2      	; 0x89e <__DATA_REGION_LENGTH__+0x9e>
 89c:	98 c0       	rjmp	.+304    	; 0x9ce <__stack+0xcf>
			{
				
			
				if (contador1 != 0)
 89e:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <contador1>
 8a2:	90 91 41 01 	lds	r25, 0x0141	; 0x800141 <contador1+0x1>
 8a6:	89 2b       	or	r24, r25
 8a8:	a9 f0       	breq	.+42     	; 0x8d4 <__DATA_REGION_LENGTH__+0xd4>
				{
					
					I2C_esclavo(5,ESCLAVO2);
 8aa:	62 e0       	ldi	r22, 0x02	; 2
 8ac:	85 e0       	ldi	r24, 0x05	; 5
 8ae:	0e 94 d7 00 	call	0x1ae	; 0x1ae <I2C_esclavo>
 8b2:	9f ef       	ldi	r25, 0xFF	; 255
 8b4:	20 e7       	ldi	r18, 0x70	; 112
 8b6:	82 e0       	ldi	r24, 0x02	; 2
 8b8:	91 50       	subi	r25, 0x01	; 1
 8ba:	20 40       	sbci	r18, 0x00	; 0
 8bc:	80 40       	sbci	r24, 0x00	; 0
 8be:	e1 f7       	brne	.-8      	; 0x8b8 <__DATA_REGION_LENGTH__+0xb8>
 8c0:	00 c0       	rjmp	.+0      	; 0x8c2 <__DATA_REGION_LENGTH__+0xc2>
 8c2:	00 00       	nop
					_delay_ms(50);
					I2C_esclavo(9,ESCLAVO2);
 8c4:	62 e0       	ldi	r22, 0x02	; 2
 8c6:	89 e0       	ldi	r24, 0x09	; 9
 8c8:	0e 94 d7 00 	call	0x1ae	; 0x1ae <I2C_esclavo>
					contador1  = 0;
 8cc:	10 92 41 01 	sts	0x0141, r1	; 0x800141 <contador1+0x1>
 8d0:	10 92 40 01 	sts	0x0140, r1	; 0x800140 <contador1>
 8d4:	8f e3       	ldi	r24, 0x3F	; 63
 8d6:	9c e9       	ldi	r25, 0x9C	; 156
 8d8:	01 97       	sbiw	r24, 0x01	; 1
 8da:	f1 f7       	brne	.-4      	; 0x8d8 <__DATA_REGION_LENGTH__+0xd8>
 8dc:	00 c0       	rjmp	.+0      	; 0x8de <__DATA_REGION_LENGTH__+0xde>
 8de:	00 00       	nop
				}
				
				
				
				_delay_ms(10);
				dato1 = I2C_leer_dato(ESCLAVO1, &dato1);   //Leer el dato del esclavo 1
 8e0:	60 e5       	ldi	r22, 0x50	; 80
 8e2:	71 e0       	ldi	r23, 0x01	; 1
 8e4:	83 e0       	ldi	r24, 0x03	; 3
 8e6:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <I2C_leer_dato>
 8ea:	90 93 51 01 	sts	0x0151, r25	; 0x800151 <dato1+0x1>
 8ee:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <dato1>
				UART_PrintNum(dato1);
 8f2:	0e 94 8b 06 	call	0xd16	; 0xd16 <UART_PrintNum>
				writeTextUART("_");    //Separador
 8f6:	84 e0       	ldi	r24, 0x04	; 4
 8f8:	91 e0       	ldi	r25, 0x01	; 1
 8fa:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				
				if (dato1 <= 3 && dato1 >1)
 8fe:	80 91 50 01 	lds	r24, 0x0150	; 0x800150 <dato1>
 902:	90 91 51 01 	lds	r25, 0x0151	; 0x800151 <dato1+0x1>
 906:	02 97       	sbiw	r24, 0x02	; 2
 908:	02 97       	sbiw	r24, 0x02	; 2
 90a:	a8 f4       	brcc	.+42     	; 0x936 <__stack+0x37>
				{
					writeTextUART("Formato grande      ");
 90c:	88 e0       	ldi	r24, 0x08	; 8
 90e:	91 e0       	ldi	r25, 0x01	; 1
 910:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
					writeTextUART("\n");
 914:	86 e0       	ldi	r24, 0x06	; 6
 916:	91 e0       	ldi	r25, 0x01	; 1
 918:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
					I2C_esclavo(6,ESCLAVO2);
 91c:	62 e0       	ldi	r22, 0x02	; 2
 91e:	86 e0       	ldi	r24, 0x06	; 6
 920:	0e 94 d7 00 	call	0x1ae	; 0x1ae <I2C_esclavo>
 924:	9f ef       	ldi	r25, 0xFF	; 255
 926:	2f e4       	ldi	r18, 0x4F	; 79
 928:	83 ec       	ldi	r24, 0xC3	; 195
 92a:	91 50       	subi	r25, 0x01	; 1
 92c:	20 40       	sbci	r18, 0x00	; 0
 92e:	80 40       	sbci	r24, 0x00	; 0
 930:	e1 f7       	brne	.-8      	; 0x92a <__stack+0x2b>
 932:	00 c0       	rjmp	.+0      	; 0x934 <__stack+0x35>
 934:	00 00       	nop
					_delay_ms(4000);
					
				}
				
				if (dato1 <= 5 && dato1 >=4)
 936:	80 91 50 01 	lds	r24, 0x0150	; 0x800150 <dato1>
 93a:	90 91 51 01 	lds	r25, 0x0151	; 0x800151 <dato1+0x1>
 93e:	04 97       	sbiw	r24, 0x04	; 4
 940:	02 97       	sbiw	r24, 0x02	; 2
 942:	b0 f4       	brcc	.+44     	; 0x970 <__stack+0x71>
				{
					writeTextUART("Formato corto     ");
 944:	8d e1       	ldi	r24, 0x1D	; 29
 946:	91 e0       	ldi	r25, 0x01	; 1
 948:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
					writeTextUART("\n");
 94c:	86 e0       	ldi	r24, 0x06	; 6
 94e:	91 e0       	ldi	r25, 0x01	; 1
 950:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
					I2C_esclavo(7,ESCLAVO2);
 954:	62 e0       	ldi	r22, 0x02	; 2
 956:	87 e0       	ldi	r24, 0x07	; 7
 958:	0e 94 d7 00 	call	0x1ae	; 0x1ae <I2C_esclavo>
 95c:	9f ef       	ldi	r25, 0xFF	; 255
 95e:	2f e4       	ldi	r18, 0x4F	; 79
 960:	83 ec       	ldi	r24, 0xC3	; 195
 962:	91 50       	subi	r25, 0x01	; 1
 964:	20 40       	sbci	r18, 0x00	; 0
 966:	80 40       	sbci	r24, 0x00	; 0
 968:	e1 f7       	brne	.-8      	; 0x962 <__stack+0x63>
 96a:	00 c0       	rjmp	.+0      	; 0x96c <__stack+0x6d>
 96c:	00 00       	nop
 96e:	08 c0       	rjmp	.+16     	; 0x980 <__stack+0x81>
					_delay_ms(4000);
				}
				else{
					writeTextUART("           ");
 970:	80 e3       	ldi	r24, 0x30	; 48
 972:	91 e0       	ldi	r25, 0x01	; 1
 974:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
					writeTextUART("\n");
 978:	86 e0       	ldi	r24, 0x06	; 6
 97a:	91 e0       	ldi	r25, 0x01	; 1
 97c:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
				}
				
				if (dato1 == 0 && contador < 1) //Bloquear envio de datos infinitos a Adafruit IO
 980:	80 91 50 01 	lds	r24, 0x0150	; 0x800150 <dato1>
 984:	90 91 51 01 	lds	r25, 0x0151	; 0x800151 <dato1+0x1>
 988:	89 2b       	or	r24, r25
 98a:	09 f5       	brne	.+66     	; 0x9ce <__stack+0xcf>
 98c:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <contador>
 990:	90 91 43 01 	lds	r25, 0x0143	; 0x800143 <contador+0x1>
 994:	18 16       	cp	r1, r24
 996:	19 06       	cpc	r1, r25
 998:	d4 f0       	brlt	.+52     	; 0x9ce <__stack+0xcf>
				{
					I2C_esclavo(5,ESCLAVO2);
 99a:	62 e0       	ldi	r22, 0x02	; 2
 99c:	85 e0       	ldi	r24, 0x05	; 5
 99e:	0e 94 d7 00 	call	0x1ae	; 0x1ae <I2C_esclavo>
 9a2:	9f ef       	ldi	r25, 0xFF	; 255
 9a4:	20 e7       	ldi	r18, 0x70	; 112
 9a6:	82 e0       	ldi	r24, 0x02	; 2
 9a8:	91 50       	subi	r25, 0x01	; 1
 9aa:	20 40       	sbci	r18, 0x00	; 0
 9ac:	80 40       	sbci	r24, 0x00	; 0
 9ae:	e1 f7       	brne	.-8      	; 0x9a8 <__stack+0xa9>
 9b0:	00 c0       	rjmp	.+0      	; 0x9b2 <__stack+0xb3>
 9b2:	00 00       	nop
					_delay_ms(50);
					I2C_esclavo(9,ESCLAVO2);
 9b4:	62 e0       	ldi	r22, 0x02	; 2
 9b6:	89 e0       	ldi	r24, 0x09	; 9
 9b8:	0e 94 d7 00 	call	0x1ae	; 0x1ae <I2C_esclavo>
					contador = contador+1;
 9bc:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <contador>
 9c0:	90 91 43 01 	lds	r25, 0x0143	; 0x800143 <contador+0x1>
 9c4:	01 96       	adiw	r24, 0x01	; 1
 9c6:	90 93 43 01 	sts	0x0143, r25	; 0x800143 <contador+0x1>
 9ca:	80 93 42 01 	sts	0x0142, r24	; 0x800142 <contador>
			
			
			
			
			
			receivedChar = 0;
 9ce:	10 92 49 01 	sts	0x0149, r1	; 0x800149 <receivedChar>
 9d2:	8f e3       	ldi	r24, 0x3F	; 63
 9d4:	9c e9       	ldi	r25, 0x9C	; 156
 9d6:	01 97       	sbiw	r24, 0x01	; 1
 9d8:	f1 f7       	brne	.-4      	; 0x9d6 <__stack+0xd7>
 9da:	00 c0       	rjmp	.+0      	; 0x9dc <__stack+0xdd>
 9dc:	00 00       	nop
 9de:	88 cc       	rjmp	.-1776   	; 0x2f0 <main+0x4>

000009e0 <__vector_18>:
}



ISR(USART_RX_vect)
{
 9e0:	1f 92       	push	r1
 9e2:	0f 92       	push	r0
 9e4:	0f b6       	in	r0, 0x3f	; 63
 9e6:	0f 92       	push	r0
 9e8:	11 24       	eor	r1, r1
 9ea:	8f 93       	push	r24
	receivedChar = UDR0; // Almacena el carácter recibido
 9ec:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
 9f0:	80 93 49 01 	sts	0x0149, r24	; 0x800149 <receivedChar>
	
	while(!(UCSR0A & (1<<UDRE0)));    //Mientras haya caracteres
 9f4:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
 9f8:	85 ff       	sbrs	r24, 5
 9fa:	fc cf       	rjmp	.-8      	; 0x9f4 <__vector_18+0x14>
	
}
 9fc:	8f 91       	pop	r24
 9fe:	0f 90       	pop	r0
 a00:	0f be       	out	0x3f, r0	; 63
 a02:	0f 90       	pop	r0
 a04:	1f 90       	pop	r1
 a06:	18 95       	reti

00000a08 <__vector_3>:


ISR(PCINT0_vect){
 a08:	1f 92       	push	r1
 a0a:	0f 92       	push	r0
 a0c:	0f b6       	in	r0, 0x3f	; 63
 a0e:	0f 92       	push	r0
 a10:	11 24       	eor	r1, r1
 a12:	2f 93       	push	r18
 a14:	3f 93       	push	r19
 a16:	4f 93       	push	r20
 a18:	5f 93       	push	r21
 a1a:	6f 93       	push	r22
 a1c:	7f 93       	push	r23
 a1e:	8f 93       	push	r24
 a20:	9f 93       	push	r25
 a22:	af 93       	push	r26
 a24:	bf 93       	push	r27
 a26:	ef 93       	push	r30
 a28:	ff 93       	push	r31
	if(((PINB) & (1<<PINB0)) == 0){   //Condicional que compara si se detecto una caja
 a2a:	18 99       	sbic	0x03, 0	; 3
 a2c:	16 c0       	rjmp	.+44     	; 0xa5a <__vector_3+0x52>
 a2e:	2f ef       	ldi	r18, 0xFF	; 255
 a30:	89 ef       	ldi	r24, 0xF9	; 249
 a32:	90 e0       	ldi	r25, 0x00	; 0
 a34:	21 50       	subi	r18, 0x01	; 1
 a36:	80 40       	sbci	r24, 0x00	; 0
 a38:	90 40       	sbci	r25, 0x00	; 0
 a3a:	e1 f7       	brne	.-8      	; 0xa34 <__vector_3+0x2c>
 a3c:	00 c0       	rjmp	.+0      	; 0xa3e <__vector_3+0x36>
 a3e:	00 00       	nop
		 
		_delay_ms(20);  //antirrebote
		
		I2C_esclavo(12,ESCLAVO1);
 a40:	63 e0       	ldi	r22, 0x03	; 3
 a42:	8c e0       	ldi	r24, 0x0C	; 12
 a44:	0e 94 d7 00 	call	0x1ae	; 0x1ae <I2C_esclavo>

		while ((PINB & (1 << PINB0)) == 0)   //While para evitar mas pulsos
 a48:	06 c0       	rjmp	.+12     	; 0xa56 <__vector_3+0x4e>
 a4a:	8f e3       	ldi	r24, 0x3F	; 63
 a4c:	9c e9       	ldi	r25, 0x9C	; 156
 a4e:	01 97       	sbiw	r24, 0x01	; 1
 a50:	f1 f7       	brne	.-4      	; 0xa4e <__vector_3+0x46>
 a52:	00 c0       	rjmp	.+0      	; 0xa54 <__vector_3+0x4c>
 a54:	00 00       	nop
 a56:	18 9b       	sbis	0x03, 0	; 3
 a58:	f8 cf       	rjmp	.-16     	; 0xa4a <__vector_3+0x42>
			_delay_ms(10);
		}
	}
	
	
	if(((PINB) & (1<<PINB1)) == 0){   //Condicional que compara si se detecto gas
 a5a:	19 99       	sbic	0x03, 1	; 3
 a5c:	44 c0       	rjmp	.+136    	; 0xae6 <__vector_3+0xde>
		I2C_esclavo(20,ESCLAVO1);
 a5e:	63 e0       	ldi	r22, 0x03	; 3
 a60:	84 e1       	ldi	r24, 0x14	; 20
 a62:	0e 94 d7 00 	call	0x1ae	; 0x1ae <I2C_esclavo>
		 UART_PrintNum(1);
 a66:	81 e0       	ldi	r24, 0x01	; 1
 a68:	90 e0       	ldi	r25, 0x00	; 0
 a6a:	0e 94 8b 06 	call	0xd16	; 0xd16 <UART_PrintNum>
		 writeTextUART("_");    //Separador
 a6e:	84 e0       	ldi	r24, 0x04	; 4
 a70:	91 e0       	ldi	r25, 0x01	; 1
 a72:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
		 writeTextUART("\n");
 a76:	86 e0       	ldi	r24, 0x06	; 6
 a78:	91 e0       	ldi	r25, 0x01	; 1
 a7a:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
 a7e:	9f ef       	ldi	r25, 0xFF	; 255
 a80:	29 ef       	ldi	r18, 0xF9	; 249
 a82:	80 e0       	ldi	r24, 0x00	; 0
 a84:	91 50       	subi	r25, 0x01	; 1
 a86:	20 40       	sbci	r18, 0x00	; 0
 a88:	80 40       	sbci	r24, 0x00	; 0
 a8a:	e1 f7       	brne	.-8      	; 0xa84 <__vector_3+0x7c>
 a8c:	00 c0       	rjmp	.+0      	; 0xa8e <__vector_3+0x86>
 a8e:	00 00       	nop
		 _delay_ms(20);
		 I2C_esclavo(20,ESCLAVO1);
 a90:	63 e0       	ldi	r22, 0x03	; 3
 a92:	84 e1       	ldi	r24, 0x14	; 20
 a94:	0e 94 d7 00 	call	0x1ae	; 0x1ae <I2C_esclavo>
 a98:	9f ef       	ldi	r25, 0xFF	; 255
 a9a:	23 ef       	ldi	r18, 0xF3	; 243
 a9c:	81 e0       	ldi	r24, 0x01	; 1
 a9e:	91 50       	subi	r25, 0x01	; 1
 aa0:	20 40       	sbci	r18, 0x00	; 0
 aa2:	80 40       	sbci	r24, 0x00	; 0
 aa4:	e1 f7       	brne	.-8      	; 0xa9e <__vector_3+0x96>
 aa6:	00 c0       	rjmp	.+0      	; 0xaa8 <__vector_3+0xa0>
 aa8:	00 00       	nop
		 _delay_ms(40);
		 I2C_esclavo(20,ESCLAVO1);
 aaa:	63 e0       	ldi	r22, 0x03	; 3
 aac:	84 e1       	ldi	r24, 0x14	; 20
 aae:	0e 94 d7 00 	call	0x1ae	; 0x1ae <I2C_esclavo>
 ab2:	8f e3       	ldi	r24, 0x3F	; 63
 ab4:	9c e9       	ldi	r25, 0x9C	; 156
 ab6:	01 97       	sbiw	r24, 0x01	; 1
 ab8:	f1 f7       	brne	.-4      	; 0xab6 <__vector_3+0xae>
 aba:	00 c0       	rjmp	.+0      	; 0xabc <__vector_3+0xb4>
 abc:	00 00       	nop
		 _delay_ms(10);
		 
		 if (contador1 < 1)
 abe:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <contador1>
 ac2:	90 91 41 01 	lds	r25, 0x0141	; 0x800141 <contador1+0x1>
 ac6:	18 16       	cp	r1, r24
 ac8:	19 06       	cpc	r1, r25
 aca:	6c f0       	brlt	.+26     	; 0xae6 <__vector_3+0xde>
		 {
		 I2C_esclavo(8,ESCLAVO2);
 acc:	62 e0       	ldi	r22, 0x02	; 2
 ace:	88 e0       	ldi	r24, 0x08	; 8
 ad0:	0e 94 d7 00 	call	0x1ae	; 0x1ae <I2C_esclavo>
		 contador1 = contador1 + 1;
 ad4:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <contador1>
 ad8:	90 91 41 01 	lds	r25, 0x0141	; 0x800141 <contador1+0x1>
 adc:	01 96       	adiw	r24, 0x01	; 1
 ade:	90 93 41 01 	sts	0x0141, r25	; 0x800141 <contador1+0x1>
 ae2:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <contador1>


	}


}
 ae6:	ff 91       	pop	r31
 ae8:	ef 91       	pop	r30
 aea:	bf 91       	pop	r27
 aec:	af 91       	pop	r26
 aee:	9f 91       	pop	r25
 af0:	8f 91       	pop	r24
 af2:	7f 91       	pop	r23
 af4:	6f 91       	pop	r22
 af6:	5f 91       	pop	r21
 af8:	4f 91       	pop	r20
 afa:	3f 91       	pop	r19
 afc:	2f 91       	pop	r18
 afe:	0f 90       	pop	r0
 b00:	0f be       	out	0x3f, r0	; 63
 b02:	0f 90       	pop	r0
 b04:	1f 90       	pop	r1
 b06:	18 95       	reti

00000b08 <__vector_1>:


ISR(INT0_vect) {
 b08:	1f 92       	push	r1
 b0a:	0f 92       	push	r0
 b0c:	0f b6       	in	r0, 0x3f	; 63
 b0e:	0f 92       	push	r0
 b10:	11 24       	eor	r1, r1
 b12:	2f 93       	push	r18
 b14:	3f 93       	push	r19
 b16:	4f 93       	push	r20
 b18:	5f 93       	push	r21
 b1a:	6f 93       	push	r22
 b1c:	7f 93       	push	r23
 b1e:	8f 93       	push	r24
 b20:	9f 93       	push	r25
 b22:	af 93       	push	r26
 b24:	bf 93       	push	r27
 b26:	ef 93       	push	r30
 b28:	ff 93       	push	r31
		if(((PIND) & (1<<DDD2)) == 0){   //Condicional que compara si se detecto una caja
 b2a:	4a 99       	sbic	0x09, 2	; 9
 b2c:	16 c0       	rjmp	.+44     	; 0xb5a <__vector_1+0x52>
 b2e:	2f ef       	ldi	r18, 0xFF	; 255
 b30:	89 ef       	ldi	r24, 0xF9	; 249
 b32:	90 e0       	ldi	r25, 0x00	; 0
 b34:	21 50       	subi	r18, 0x01	; 1
 b36:	80 40       	sbci	r24, 0x00	; 0
 b38:	90 40       	sbci	r25, 0x00	; 0
 b3a:	e1 f7       	brne	.-8      	; 0xb34 <__vector_1+0x2c>
 b3c:	00 c0       	rjmp	.+0      	; 0xb3e <__vector_1+0x36>
 b3e:	00 00       	nop
			_delay_ms(20);  //antirrebote
			
			I2C_esclavo(13,ESCLAVO1);
 b40:	63 e0       	ldi	r22, 0x03	; 3
 b42:	8d e0       	ldi	r24, 0x0D	; 13
 b44:	0e 94 d7 00 	call	0x1ae	; 0x1ae <I2C_esclavo>
			while ((PIND & (1 << DDD2)) == 0)   //While para evitar mas pulsos
 b48:	06 c0       	rjmp	.+12     	; 0xb56 <__vector_1+0x4e>
 b4a:	8f e3       	ldi	r24, 0x3F	; 63
 b4c:	9c e9       	ldi	r25, 0x9C	; 156
 b4e:	01 97       	sbiw	r24, 0x01	; 1
 b50:	f1 f7       	brne	.-4      	; 0xb4e <__vector_1+0x46>
 b52:	00 c0       	rjmp	.+0      	; 0xb54 <__vector_1+0x4c>
 b54:	00 00       	nop
 b56:	4a 9b       	sbis	0x09, 2	; 9
 b58:	f8 cf       	rjmp	.-16     	; 0xb4a <__vector_1+0x42>
			{
				_delay_ms(10);
			}
}
}
 b5a:	ff 91       	pop	r31
 b5c:	ef 91       	pop	r30
 b5e:	bf 91       	pop	r27
 b60:	af 91       	pop	r26
 b62:	9f 91       	pop	r25
 b64:	8f 91       	pop	r24
 b66:	7f 91       	pop	r23
 b68:	6f 91       	pop	r22
 b6a:	5f 91       	pop	r21
 b6c:	4f 91       	pop	r20
 b6e:	3f 91       	pop	r19
 b70:	2f 91       	pop	r18
 b72:	0f 90       	pop	r0
 b74:	0f be       	out	0x3f, r0	; 63
 b76:	0f 90       	pop	r0
 b78:	1f 90       	pop	r1
 b7a:	18 95       	reti

00000b7c <BCD_to_Decimal>:

	I2C_STOP();
}

uint8_t BCD_to_Decimal(uint8_t bcd) {
	return ((bcd >> 4) * 10) + (bcd & 0x0F);
 b7c:	98 2f       	mov	r25, r24
 b7e:	92 95       	swap	r25
 b80:	9f 70       	andi	r25, 0x0F	; 15
 b82:	99 0f       	add	r25, r25
 b84:	29 2f       	mov	r18, r25
 b86:	22 0f       	add	r18, r18
 b88:	22 0f       	add	r18, r18
 b8a:	92 0f       	add	r25, r18
 b8c:	8f 70       	andi	r24, 0x0F	; 15
}
 b8e:	89 0f       	add	r24, r25
 b90:	08 95       	ret

00000b92 <I2C_leerACK>:


uint8_t I2C_leerACK() {
	TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWEA);
 b92:	84 ec       	ldi	r24, 0xC4	; 196
 b94:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
	while (!(TWCR & (1 << TWINT)));
 b98:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
 b9c:	88 23       	and	r24, r24
 b9e:	e4 f7       	brge	.-8      	; 0xb98 <I2C_leerACK+0x6>
	return TWDR;
 ba0:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7f80bb>
}
 ba4:	08 95       	ret

00000ba6 <I2C_leerNACK>:

uint8_t I2C_leerNACK() {
	TWCR = (1 << TWINT) | (1 << TWEN);
 ba6:	84 e8       	ldi	r24, 0x84	; 132
 ba8:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
	while (!(TWCR & (1 << TWINT)));
 bac:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
 bb0:	88 23       	and	r24, r24
 bb2:	e4 f7       	brge	.-8      	; 0xbac <I2C_leerNACK+0x6>
	return TWDR;
 bb4:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7f80bb>
}
 bb8:	08 95       	ret

00000bba <leer_fecha_hora>:

#define SLA_R(address) ((address << 1) | 1)  // Define la macro SLA_R
#define SLA_W(address) (address << 1)

// Función para leer la fecha y hora del DS3231
void leer_fecha_hora(uint8_t *segundos, uint8_t *minutos, uint8_t *horas, uint8_t *dia, uint8_t *fecha, uint8_t *mes, uint8_t *anio) {
 bba:	6f 92       	push	r6
 bbc:	7f 92       	push	r7
 bbe:	8f 92       	push	r8
 bc0:	9f 92       	push	r9
 bc2:	af 92       	push	r10
 bc4:	bf 92       	push	r11
 bc6:	cf 92       	push	r12
 bc8:	df 92       	push	r13
 bca:	ef 92       	push	r14
 bcc:	ff 92       	push	r15
 bce:	0f 93       	push	r16
 bd0:	1f 93       	push	r17
 bd2:	cf 93       	push	r28
 bd4:	df 93       	push	r29
 bd6:	4c 01       	movw	r8, r24
 bd8:	5b 01       	movw	r10, r22
 bda:	ea 01       	movw	r28, r20
 bdc:	39 01       	movw	r6, r18
	I2C_inicio();
 bde:	0e 94 a5 00 	call	0x14a	; 0x14a <I2C_inicio>
	I2C_EscByte(SLA_W(0x68));  // Dirección del esclavo con bit de escritura
 be2:	80 ed       	ldi	r24, 0xD0	; 208
 be4:	90 e0       	ldi	r25, 0x00	; 0
 be6:	0e 94 b7 00 	call	0x16e	; 0x16e <I2C_EscByte>
	I2C_EscByte(0x00);         // Dirección del primer registro (segundos)
 bea:	80 e0       	ldi	r24, 0x00	; 0
 bec:	90 e0       	ldi	r25, 0x00	; 0
 bee:	0e 94 b7 00 	call	0x16e	; 0x16e <I2C_EscByte>
	I2C_inicio();
 bf2:	0e 94 a5 00 	call	0x14a	; 0x14a <I2C_inicio>
	I2C_EscByte(SLA_R(0x68));  // Dirección del esclavo con bit de lectura
 bf6:	81 ed       	ldi	r24, 0xD1	; 209
 bf8:	90 e0       	ldi	r25, 0x00	; 0
 bfa:	0e 94 b7 00 	call	0x16e	; 0x16e <I2C_EscByte>

	*segundos = BCD_to_Decimal(I2C_leerACK());
 bfe:	0e 94 c9 05 	call	0xb92	; 0xb92 <I2C_leerACK>
 c02:	0e 94 be 05 	call	0xb7c	; 0xb7c <BCD_to_Decimal>
 c06:	f4 01       	movw	r30, r8
 c08:	80 83       	st	Z, r24
	*minutos = BCD_to_Decimal(I2C_leerACK());
 c0a:	0e 94 c9 05 	call	0xb92	; 0xb92 <I2C_leerACK>
 c0e:	0e 94 be 05 	call	0xb7c	; 0xb7c <BCD_to_Decimal>
 c12:	f5 01       	movw	r30, r10
 c14:	80 83       	st	Z, r24
	*horas = BCD_to_Decimal(I2C_leerACK());
 c16:	0e 94 c9 05 	call	0xb92	; 0xb92 <I2C_leerACK>
 c1a:	0e 94 be 05 	call	0xb7c	; 0xb7c <BCD_to_Decimal>
 c1e:	88 83       	st	Y, r24
	*dia = BCD_to_Decimal(I2C_leerACK());
 c20:	0e 94 c9 05 	call	0xb92	; 0xb92 <I2C_leerACK>
 c24:	0e 94 be 05 	call	0xb7c	; 0xb7c <BCD_to_Decimal>
 c28:	f3 01       	movw	r30, r6
 c2a:	80 83       	st	Z, r24
	*fecha = BCD_to_Decimal(I2C_leerACK());
 c2c:	0e 94 c9 05 	call	0xb92	; 0xb92 <I2C_leerACK>
 c30:	0e 94 be 05 	call	0xb7c	; 0xb7c <BCD_to_Decimal>
 c34:	f8 01       	movw	r30, r16
 c36:	80 83       	st	Z, r24
	*mes = BCD_to_Decimal(I2C_leerACK());
 c38:	0e 94 c9 05 	call	0xb92	; 0xb92 <I2C_leerACK>
 c3c:	0e 94 be 05 	call	0xb7c	; 0xb7c <BCD_to_Decimal>
 c40:	f7 01       	movw	r30, r14
 c42:	80 83       	st	Z, r24
	*anio = BCD_to_Decimal(I2C_leerNACK());
 c44:	0e 94 d3 05 	call	0xba6	; 0xba6 <I2C_leerNACK>
 c48:	0e 94 be 05 	call	0xb7c	; 0xb7c <BCD_to_Decimal>
 c4c:	f6 01       	movw	r30, r12
 c4e:	80 83       	st	Z, r24

	I2C_STOP();
 c50:	0e 94 cf 00 	call	0x19e	; 0x19e <I2C_STOP>
}
 c54:	df 91       	pop	r29
 c56:	cf 91       	pop	r28
 c58:	1f 91       	pop	r17
 c5a:	0f 91       	pop	r16
 c5c:	ff 90       	pop	r15
 c5e:	ef 90       	pop	r14
 c60:	df 90       	pop	r13
 c62:	cf 90       	pop	r12
 c64:	bf 90       	pop	r11
 c66:	af 90       	pop	r10
 c68:	9f 90       	pop	r9
 c6a:	8f 90       	pop	r8
 c6c:	7f 90       	pop	r7
 c6e:	6f 90       	pop	r6
 c70:	08 95       	ret

00000c72 <SPI_init>:
	/*	Pines de control para esclavos
		PB2: Esclavo 1
	*/
	
	
	DDRB |= (1<<DDB2) | (1<<DDB3) | (1<<DDB5);   //SS, MOSI, and SCK OUTPUT in master mode
 c72:	84 b1       	in	r24, 0x04	; 4
 c74:	8c 62       	ori	r24, 0x2C	; 44
 c76:	84 b9       	out	0x04, r24	; 4
	DDRB &= ~(1<<DDB4);  //MISO como entrada
 c78:	84 b1       	in	r24, 0x04	; 4
 c7a:	8f 7e       	andi	r24, 0xEF	; 239
 c7c:	84 b9       	out	0x04, r24	; 4

	/*	Orden de salida de los datos 
		DORD = 0, El bit más significativo (MSB) es enviado primero
		DORD = 1, El bit menos significativo (LSB) es enviado primero
	*/
	SPCR &=~ (1<<DORD);
 c7e:	8c b5       	in	r24, 0x2c	; 44
 c80:	8f 7d       	andi	r24, 0xDF	; 223
 c82:	8c bd       	out	0x2c, r24	; 44
		  0	  |   0    |  Clock inactivo en bajo, detección de bits en flanco de subida
		  0	  |   1    |  Clock inactivo en bajo, detección de bits en flanco de bajada
		  1	  |   0    |  Clock inactivo en alto, detección de bits en flanco de bajada
		  1	  |   1    |  Clock inactivo en alto, detección de bits en flanco de subida			
	*/
	SPCR &=~ (1<<CPOL);
 c84:	8c b5       	in	r24, 0x2c	; 44
 c86:	87 7f       	andi	r24, 0xF7	; 247
 c88:	8c bd       	out	0x2c, r24	; 44
	SPCR &=~ (1<<CPHA);
 c8a:	8c b5       	in	r24, 0x2c	; 44
 c8c:	8b 7f       	andi	r24, 0xFB	; 251
 c8e:	8c bd       	out	0x2c, r24	; 44
		1	  | 1	 |	0	|	32
		1	  | 1	 |	1	|	64
		
		F_CPU=16MHz -> F_SPI= F_CPU/16= 1MHz		 
	*/
	SPCR |=  (1<<SPR0);
 c90:	8c b5       	in	r24, 0x2c	; 44
 c92:	81 60       	ori	r24, 0x01	; 1
 c94:	8c bd       	out	0x2c, r24	; 44
	SPCR &=~ (1<<SPR1);
 c96:	8c b5       	in	r24, 0x2c	; 44
 c98:	8d 7f       	andi	r24, 0xFD	; 253
 c9a:	8c bd       	out	0x2c, r24	; 44
	SPSR &=~ (1<<SPI2X);
 c9c:	8d b5       	in	r24, 0x2d	; 45
 c9e:	8e 7f       	andi	r24, 0xFE	; 254
 ca0:	8d bd       	out	0x2d, r24	; 45

	/*	Modo de funcionamiento 
		MSTR = 0, SPI como esclavo
		MSTR = 1; SPI como maestro
	*/
	SPCR |= (1<<MSTR);
 ca2:	8c b5       	in	r24, 0x2c	; 44
 ca4:	80 61       	ori	r24, 0x10	; 16
 ca6:	8c bd       	out	0x2c, r24	; 44

	/* Activar SPI 
		SPE = 0, SPI desactivado
		SPE = |, SPI activado
	*/
	SPCR |= (1<<SPE);
 ca8:	8c b5       	in	r24, 0x2c	; 44
 caa:	80 64       	ori	r24, 0x40	; 64
 cac:	8c bd       	out	0x2c, r24	; 44
 cae:	08 95       	ret

00000cb0 <initUART9600>:
#include "UART.h"

void initUART9600()
{
	//Paso 1: RX y TX como salida
	DDRD &= ~(1<<DDD0);
 cb0:	8a b1       	in	r24, 0x0a	; 10
 cb2:	8e 7f       	andi	r24, 0xFE	; 254
 cb4:	8a b9       	out	0x0a, r24	; 10
	DDRD |= (1<<DDD1);
 cb6:	8a b1       	in	r24, 0x0a	; 10
 cb8:	82 60       	ori	r24, 0x02	; 2
 cba:	8a b9       	out	0x0a, r24	; 10
	
	//Paso 2:Configurar UCSR0A
	UCSR0A = 0;
 cbc:	10 92 c0 00 	sts	0x00C0, r1	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
	
	//Paso 3: configurar UCSR0B donde se habilita ISR de recepcion y se habilita RX y TX
	UCSR0B = 0;
 cc0:	e1 ec       	ldi	r30, 0xC1	; 193
 cc2:	f0 e0       	ldi	r31, 0x00	; 0
 cc4:	10 82       	st	Z, r1
	UCSR0B |= (1<<RXCIE0) | (1<<RXEN0) | (1<<TXEN0);
 cc6:	80 81       	ld	r24, Z
 cc8:	88 69       	ori	r24, 0x98	; 152
 cca:	80 83       	st	Z, r24
	
	//Paso 4: Configurar UCSR0C, asincrono, paridad: none, 1 bit stop, data bits de 8 bits
	UCSR0C = 0;
 ccc:	e2 ec       	ldi	r30, 0xC2	; 194
 cce:	f0 e0       	ldi	r31, 0x00	; 0
 cd0:	10 82       	st	Z, r1
	UCSR0C |= (1<<UCSZ01) | (1<<UCSZ00);
 cd2:	80 81       	ld	r24, Z
 cd4:	86 60       	ori	r24, 0x06	; 6
 cd6:	80 83       	st	Z, r24
	
	//Paso 5: Configurar velocidad de baudrate a 9600
	UBRR0 = 103;
 cd8:	87 e6       	ldi	r24, 0x67	; 103
 cda:	90 e0       	ldi	r25, 0x00	; 0
 cdc:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
 ce0:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>
 ce4:	08 95       	ret

00000ce6 <writeTextUART>:
	
}


//Funcion de escritura de una cadena de caracteres
void writeTextUART(char * Texto){
 ce6:	ac 01       	movw	r20, r24
	uint8_t o;
	for(o = 0; Texto[o]!= '\0'; o++){
 ce8:	20 e0       	ldi	r18, 0x00	; 0
 cea:	07 c0       	rjmp	.+14     	; 0xcfa <writeTextUART+0x14>
		while(!(UCSR0A & (1<<UDRE0)));
 cec:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
 cf0:	95 ff       	sbrs	r25, 5
 cf2:	fc cf       	rjmp	.-8      	; 0xcec <writeTextUART+0x6>
		UDR0 = Texto[o];
 cf4:	30 93 c6 00 	sts	0x00C6, r19	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>


//Funcion de escritura de una cadena de caracteres
void writeTextUART(char * Texto){
	uint8_t o;
	for(o = 0; Texto[o]!= '\0'; o++){
 cf8:	2f 5f       	subi	r18, 0xFF	; 255
 cfa:	fa 01       	movw	r30, r20
 cfc:	e2 0f       	add	r30, r18
 cfe:	f1 1d       	adc	r31, r1
 d00:	30 81       	ld	r19, Z
 d02:	31 11       	cpse	r19, r1
 d04:	f3 cf       	rjmp	.-26     	; 0xcec <writeTextUART+0x6>
		while(!(UCSR0A & (1<<UDRE0)));
		UDR0 = Texto[o];
	}
}
 d06:	08 95       	ret

00000d08 <writeUART>:


//Funcion de escritura de un caracter
void writeUART(char Caracter)
{
	while(!(UCSR0A & (1<<UDRE0)));  //hasta que la bandera este en 1
 d08:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
 d0c:	95 ff       	sbrs	r25, 5
 d0e:	fc cf       	rjmp	.-8      	; 0xd08 <writeUART>
	UDR0 = Caracter;
 d10:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
 d14:	08 95       	ret

00000d16 <UART_PrintNum>:
	
}

void UART_PrintNum(uint16_t num) {
 d16:	cf 93       	push	r28
 d18:	df 93       	push	r29
 d1a:	00 d0       	rcall	.+0      	; 0xd1c <UART_PrintNum+0x6>
 d1c:	00 d0       	rcall	.+0      	; 0xd1e <UART_PrintNum+0x8>
 d1e:	00 d0       	rcall	.+0      	; 0xd20 <UART_PrintNum+0xa>
 d20:	cd b7       	in	r28, 0x3d	; 61
 d22:	de b7       	in	r29, 0x3e	; 62
	char buffer[6];
	itoa(num, buffer, 10);
 d24:	4a e0       	ldi	r20, 0x0A	; 10
 d26:	50 e0       	ldi	r21, 0x00	; 0
 d28:	be 01       	movw	r22, r28
 d2a:	6f 5f       	subi	r22, 0xFF	; 255
 d2c:	7f 4f       	sbci	r23, 0xFF	; 255
 d2e:	0e 94 c8 06 	call	0xd90	; 0xd90 <itoa>
	writeTextUART(buffer);
 d32:	ce 01       	movw	r24, r28
 d34:	01 96       	adiw	r24, 0x01	; 1
 d36:	0e 94 73 06 	call	0xce6	; 0xce6 <writeTextUART>
}
 d3a:	26 96       	adiw	r28, 0x06	; 6
 d3c:	0f b6       	in	r0, 0x3f	; 63
 d3e:	f8 94       	cli
 d40:	de bf       	out	0x3e, r29	; 62
 d42:	0f be       	out	0x3f, r0	; 63
 d44:	cd bf       	out	0x3d, r28	; 61
 d46:	df 91       	pop	r29
 d48:	cf 91       	pop	r28
 d4a:	08 95       	ret

00000d4c <__udivmodsi4>:
 d4c:	a1 e2       	ldi	r26, 0x21	; 33
 d4e:	1a 2e       	mov	r1, r26
 d50:	aa 1b       	sub	r26, r26
 d52:	bb 1b       	sub	r27, r27
 d54:	fd 01       	movw	r30, r26
 d56:	0d c0       	rjmp	.+26     	; 0xd72 <__udivmodsi4_ep>

00000d58 <__udivmodsi4_loop>:
 d58:	aa 1f       	adc	r26, r26
 d5a:	bb 1f       	adc	r27, r27
 d5c:	ee 1f       	adc	r30, r30
 d5e:	ff 1f       	adc	r31, r31
 d60:	a2 17       	cp	r26, r18
 d62:	b3 07       	cpc	r27, r19
 d64:	e4 07       	cpc	r30, r20
 d66:	f5 07       	cpc	r31, r21
 d68:	20 f0       	brcs	.+8      	; 0xd72 <__udivmodsi4_ep>
 d6a:	a2 1b       	sub	r26, r18
 d6c:	b3 0b       	sbc	r27, r19
 d6e:	e4 0b       	sbc	r30, r20
 d70:	f5 0b       	sbc	r31, r21

00000d72 <__udivmodsi4_ep>:
 d72:	66 1f       	adc	r22, r22
 d74:	77 1f       	adc	r23, r23
 d76:	88 1f       	adc	r24, r24
 d78:	99 1f       	adc	r25, r25
 d7a:	1a 94       	dec	r1
 d7c:	69 f7       	brne	.-38     	; 0xd58 <__udivmodsi4_loop>
 d7e:	60 95       	com	r22
 d80:	70 95       	com	r23
 d82:	80 95       	com	r24
 d84:	90 95       	com	r25
 d86:	9b 01       	movw	r18, r22
 d88:	ac 01       	movw	r20, r24
 d8a:	bd 01       	movw	r22, r26
 d8c:	cf 01       	movw	r24, r30
 d8e:	08 95       	ret

00000d90 <itoa>:
 d90:	45 32       	cpi	r20, 0x25	; 37
 d92:	51 05       	cpc	r21, r1
 d94:	20 f4       	brcc	.+8      	; 0xd9e <itoa+0xe>
 d96:	42 30       	cpi	r20, 0x02	; 2
 d98:	10 f0       	brcs	.+4      	; 0xd9e <itoa+0xe>
 d9a:	0c 94 d3 06 	jmp	0xda6	; 0xda6 <__itoa_ncheck>
 d9e:	fb 01       	movw	r30, r22
 da0:	10 82       	st	Z, r1
 da2:	cb 01       	movw	r24, r22
 da4:	08 95       	ret

00000da6 <__itoa_ncheck>:
 da6:	bb 27       	eor	r27, r27
 da8:	4a 30       	cpi	r20, 0x0A	; 10
 daa:	31 f4       	brne	.+12     	; 0xdb8 <__itoa_ncheck+0x12>
 dac:	99 23       	and	r25, r25
 dae:	22 f4       	brpl	.+8      	; 0xdb8 <__itoa_ncheck+0x12>
 db0:	bd e2       	ldi	r27, 0x2D	; 45
 db2:	90 95       	com	r25
 db4:	81 95       	neg	r24
 db6:	9f 4f       	sbci	r25, 0xFF	; 255
 db8:	0c 94 df 06 	jmp	0xdbe	; 0xdbe <__utoa_common>

00000dbc <__utoa_ncheck>:
 dbc:	bb 27       	eor	r27, r27

00000dbe <__utoa_common>:
 dbe:	fb 01       	movw	r30, r22
 dc0:	55 27       	eor	r21, r21
 dc2:	aa 27       	eor	r26, r26
 dc4:	88 0f       	add	r24, r24
 dc6:	99 1f       	adc	r25, r25
 dc8:	aa 1f       	adc	r26, r26
 dca:	a4 17       	cp	r26, r20
 dcc:	10 f0       	brcs	.+4      	; 0xdd2 <__utoa_common+0x14>
 dce:	a4 1b       	sub	r26, r20
 dd0:	83 95       	inc	r24
 dd2:	50 51       	subi	r21, 0x10	; 16
 dd4:	b9 f7       	brne	.-18     	; 0xdc4 <__utoa_common+0x6>
 dd6:	a0 5d       	subi	r26, 0xD0	; 208
 dd8:	aa 33       	cpi	r26, 0x3A	; 58
 dda:	08 f0       	brcs	.+2      	; 0xdde <__utoa_common+0x20>
 ddc:	a9 5d       	subi	r26, 0xD9	; 217
 dde:	a1 93       	st	Z+, r26
 de0:	00 97       	sbiw	r24, 0x00	; 0
 de2:	79 f7       	brne	.-34     	; 0xdc2 <__utoa_common+0x4>
 de4:	b1 11       	cpse	r27, r1
 de6:	b1 93       	st	Z+, r27
 de8:	11 92       	st	Z+, r1
 dea:	cb 01       	movw	r24, r22
 dec:	0c 94 f8 06 	jmp	0xdf0	; 0xdf0 <strrev>

00000df0 <strrev>:
 df0:	dc 01       	movw	r26, r24
 df2:	fc 01       	movw	r30, r24
 df4:	67 2f       	mov	r22, r23
 df6:	71 91       	ld	r23, Z+
 df8:	77 23       	and	r23, r23
 dfa:	e1 f7       	brne	.-8      	; 0xdf4 <strrev+0x4>
 dfc:	32 97       	sbiw	r30, 0x02	; 2
 dfe:	04 c0       	rjmp	.+8      	; 0xe08 <strrev+0x18>
 e00:	7c 91       	ld	r23, X
 e02:	6d 93       	st	X+, r22
 e04:	70 83       	st	Z, r23
 e06:	62 91       	ld	r22, -Z
 e08:	ae 17       	cp	r26, r30
 e0a:	bf 07       	cpc	r27, r31
 e0c:	c8 f3       	brcs	.-14     	; 0xe00 <strrev+0x10>
 e0e:	08 95       	ret

00000e10 <_exit>:
 e10:	f8 94       	cli

00000e12 <__stop_program>:
 e12:	ff cf       	rjmp	.-2      	; 0xe12 <__stop_program>
